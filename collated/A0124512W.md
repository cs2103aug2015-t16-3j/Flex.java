# A0124512W
###### src\Checker.java
``` java

// Checker.java contains the original checkTask() and checkDate() methods.
// Both methods return boolean values.
// checkTask() uses checkDate()

public class Checker {

	// that is, it is valid only if its starting time, or ending time, are NOT
	// between the starting
	// and ending times of existing tasks which are NOT DONE YET

	// number of days in each month for non-leap years
	private static final int JANUARY_DAYS = 31;
	private static final int FEBRUARY_DAYS = 28;
	private static final int MARCH_DAYS = 31;
	private static final int APRIL_DAYS = 30;
	private static final int MAY_DAYS = 31;
	private static final int JUNE_DAYS = 30;
	private static final int JULY_DAYS = 31;
	private static final int AUGUST_DAYS = 31;
	private static final int SEPTEMBER_DAYS = 30;
	private static final int OCTOBER_DAYS = 31;
	private static final int NOVEMBER_DAYS = 30;
	private static final int DECEMBER_DAYS = 31;

	private static final String DONE_STRING = "[done]";

	// checks a string containing the time, on whether it is in the required
	// format
	static boolean isValidTime(String time) {

		String tempString = new String("");
		if (time == null) {
			return false;
		}
        tempString = time.trim();

		// ENDING TIME

		// e.g. 1100

		// checks if the time is missing
		if (tempString.length() == 0) {
            return false;
		}

		// checks if there is a dash in the time
		if (tempString.indexOf("-") >= 0) {
            return false;
		}

		// checks if the time is a number
		char[] tempCharArray5 = new char[tempString.length()];
		tempString.getChars(0, tempString.length(), tempCharArray5, 0);

		for (int m = 0; m < tempString.length(); m++) {
			if (!Character.isDigit(tempCharArray5[m])) {
                return false;
			}
		}

		// checks if the time has four digits
		if (tempString.length() != 4) {
            return false;
		}

		// checks if the hours for the time, is more than 23
		if (Integer.valueOf(tempString.substring(0, 2)) > 23) {
            return false;
		}

		// checks if the minutes for the time, is more than 59
		if (Integer.valueOf(tempString.substring(2, 4)) > 59) {
           return false;
		}

		// checks if the time is a number greater than 2359 (11:59pm)
		if (Integer.valueOf(tempString) > 2359) {
            return false;
		}
        return true;
	}

	/// checks the validity of the date,
	// not perfectly for the day,
	// but perfectly for the month and the year
	static boolean isValidDate(String dateString) {
		String tempDateString = dateString;
		if (dateString == null) {
			return false;
		}

		int slashIndex1 = tempDateString.indexOf("/");

		// DAY IN DATE
        // e.g. 27
        // checks for the first slash in the date
		if (slashIndex1 < 0) {
           return false;
		}

		// e.g. tempDateString.substring(0, slashIndex1) is "27"

		// checks for any missing of the day in the date
		if (tempDateString.substring(0, slashIndex1).trim().length() == 0) {
            return false;
		}

		// checks for any "-" (dash) in the day of the date
		if (tempDateString.substring(0, slashIndex1).trim().indexOf("-") >= 0) {
            return false;
		}

		// checks if the day in the date is a number
		char[] tempCharArray1 = new char[tempDateString.substring(0, slashIndex1).trim().length()];
		tempDateString.substring(0, slashIndex1).getChars(0, tempDateString.substring(0, slashIndex1).trim().length(),
				tempCharArray1, 0);
		for (int i = 0; i < tempDateString.substring(0, slashIndex1).trim().length(); i++) {
			if (!Character.isDigit(tempCharArray1[i])) {
               return false;
			}
		}

		// checks if the day has more than two digits
		if (tempDateString.substring(0, slashIndex1).trim().length() > 2) {
            return false;
		}

		// checks whether the day in the date is more than 31
		if (Integer.valueOf(tempDateString.substring(0, slashIndex1).trim()) > 31) {
            return false;
		}

		// checks whether the day in the date is 0, or less than zero
		if (Integer.valueOf(tempDateString.substring(0, slashIndex1).trim()) <= 0) {
            return false;
		}

		int day = Integer.valueOf(tempDateString.substring(0, slashIndex1).trim());

		// e.g. tempDateString is "9/2015"

		tempDateString = tempDateString.substring(slashIndex1 + 1);

		int slashIndex2 = tempDateString.indexOf("/");

		// checks for the second slash in the date
		if (slashIndex2 < 0) {
           return false;
		}

		// MONTH IN DATE
        // e.g. tempDateString.substring(0, slashIndex2) is "9"
		// checks for any missing of the month in the date
		if (tempDateString.substring(0, slashIndex2).trim().length() == 0) {
			return false;
		}

		// checks for any "-" (dash) in the month of the date
		if (tempDateString.substring(0, slashIndex2).trim().indexOf("-") >= 0) {
			return false;
		}

		// checks if the month in the date is a number
		char[] tempCharArray2 = new char[tempDateString.substring(0, slashIndex2).trim().length()];
		tempDateString.substring(0, slashIndex2).getChars(0, tempDateString.substring(0, slashIndex2).trim().length(),
				tempCharArray2, 0);
		for (int j = 0; j < tempDateString.substring(0, slashIndex2).trim().length(); j++) {
			if (!Character.isDigit(tempCharArray2[j])) {
				return false;
			}
		}

		// checks if the month has more than two digits
		if (tempDateString.substring(0, slashIndex2).trim().length() > 2) {
			return false;
		}

		// checks if the month is more than 12
		if (Integer.valueOf(tempDateString.substring(0, slashIndex2)) > 12) {
			return false;
		}

		// checks if the month is 0, or less than 0
		if (Integer.valueOf(tempDateString.substring(0, slashIndex2)) <= 0) {
			return false;
		}

		int month = Integer.valueOf(tempDateString.substring(0, slashIndex2));

		// YEAR IN DATE

		// e.g. tempDateString.substring(slashIndex2 + 1) is "2015"

		// checks for any missing of the month in the date
		if (tempDateString.substring(slashIndex2 + 1).trim().length() == 0) {
			return false;
		}

		// checks for any "-" (dash) in the month of the date
		if (tempDateString.substring(slashIndex2 + 1).trim().indexOf("-") >= 0) {
			return false;
		}

		// checks if the year in the date is a number
		char[] tempCharArray3 = new char[tempDateString.substring(slashIndex2 + 1).trim().length()];
		tempDateString.substring(slashIndex2 + 1).getChars(0, tempDateString.substring(slashIndex2 + 1).trim().length(),
				tempCharArray3, 0);
		for (int k = 0; k < tempDateString.substring(slashIndex2 + 1).trim().length(); k++) {
			if (!Character.isDigit(tempCharArray3[k])) {
				return false;
			}
		}

		// checks if the year is 0, or less than 0
		if (Integer.valueOf(tempDateString.substring(slashIndex2 + 1)) <= 0) {
			return false;
		}

		int year = Integer.valueOf(tempDateString.substring(slashIndex2 + 1));

		if ((month == 1) && (day > JANUARY_DAYS)) {
			return false;
		} else if (month == 2) {
			boolean isLeapYear = (year % 4 == 0);

			if ((!isLeapYear) && (day > FEBRUARY_DAYS)) {
				return false;
			} else if ((isLeapYear) && (day > (FEBRUARY_DAYS + 1))) {
				return false;
			}
		} else if ((month == 3) && (day > MARCH_DAYS)) {
			return false;
		} else if ((month == 4) && (day > APRIL_DAYS)) {
			return false;
		} else if ((month == 5) && (day > MAY_DAYS)) {
			return false;
		} else if ((month == 6) && (day > JUNE_DAYS)) {
			return false;
		} else if ((month == 7) && (day > JULY_DAYS)) {
			return false;
		} else if ((month == 8) && (day > AUGUST_DAYS)) {
			return false;
		} else if ((month == 9) && (day > SEPTEMBER_DAYS)) {
			return false;
		} else if ((month == 10) && (day > OCTOBER_DAYS)) {
			return false;
		} else if ((month == 11) && (day > NOVEMBER_DAYS)) {
			return false;
		} else if ((month == 12) && (day > DECEMBER_DAYS)) {
			return false;
		}
		return true;
	}

	// makes sure that a floating task's input String, will not have ";"
	// (semicolons)
	// as they are used as separators (not needed by a floating task)
	// format: <taskname>
	static boolean isFloatingTaskInput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		tempString = string.trim();

		int semicolonIndex = tempString.indexOf(";");
		if (semicolonIndex >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex1 = tempString.indexOf(DONE_STRING);
		if (doneStringIndex1 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex2 = tempString.indexOf("[done");
		if (doneStringIndex2 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex3 = tempString.indexOf("done]");
		if (doneStringIndex3 >= 0) {
			return false;
		}

		return true;

	}

	// done floating task (user input command or file storage format)
	static boolean isDoneFloatingTaskInput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		int semicolonIndex = tempString.indexOf(";");
		if (semicolonIndex >= 0) {
			return false;
		}

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceDoneStringIndex = tempString.indexOf(" [done]");

		if (whitespaceDoneStringIndex < 0) {
			return false;
		}

		String afterDoneString = tempString.substring(whitespaceDoneStringIndex + 7).trim();

		if (afterDoneString.length() != 0) {
			return false;
		}

		tempString = tempString.substring(0, whitespaceDoneStringIndex).trim();

		if (tempString.length() == 0) {
			return false;
		}

		if (!Checker.isFloatingTaskInput(tempString)) {
			return false;
		}

		return true;
	}

	// makes sure that a floating task's display(output on the GUI) String, will
	// not have ";" (semicolons)
	// as they are used as separators (not needed by a floating task)
	// format: <taskname>
	static boolean isFloatingTaskOutput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		int semicolonIndex = tempString.indexOf(";");
		if (semicolonIndex >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex1 = tempString.indexOf(DONE_STRING);
		if (doneStringIndex1 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex2 = tempString.indexOf("[done");
		if (doneStringIndex2 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex3 = tempString.indexOf("done]");
		if (doneStringIndex3 >= 0) {
			return false;
		}

		return true;
	}

	// makes sure that a floating task is done (GUI Display form)
	// format: <taskname> [done]
	static boolean isDoneFloatingTaskOutput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		int semicolonIndex = tempString.indexOf(";");
		if (semicolonIndex >= 0) {
			return false;
		}

		int whitespaceDoneStringIndex = tempString.indexOf(" [done]");

		if (whitespaceDoneStringIndex < 0) {
			return false;
		}

		String afterDoneString = tempString.substring(whitespaceDoneStringIndex + 7).trim();

		if (afterDoneString.length() != 0) {
			return false;
		}

		tempString = tempString.substring(0, whitespaceDoneStringIndex).trim();

		if (tempString.length() == 0) {
			return false;
		}

		if (!Checker.isFloatingTaskOutput(tempString)) {
			return false;
		}

		return true;
	}

	// checks if the input of a deadline is acceptable
	// <taskname>; by <end> on <date>
	static boolean isDeadlineTaskInput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex1 = tempString.indexOf(DONE_STRING);
		if (doneStringIndex1 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex2 = tempString.indexOf("[done");
		if (doneStringIndex2 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex3 = tempString.indexOf("done]");
		if (doneStringIndex3 >= 0) {
			return false;
		}

		int semicolonWhitespaceIndex1 = tempString.indexOf("; ");

		if (semicolonWhitespaceIndex1 <= 0) {
			return false;
		}

		String taskName = tempString.substring(0, semicolonWhitespaceIndex1).trim();

		if (taskName.length() == 0) {
			return false;
		}

		tempString = tempString.substring(semicolonWhitespaceIndex1 + 2).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int byWhitespaceIndex1 = tempString.toLowerCase().indexOf("by ");

		if (byWhitespaceIndex1 < 0) {
			return false;
		}

		tempString = tempString.substring(byWhitespaceIndex1 + 3).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceOnWhitespaceIndex1 = tempString.toLowerCase().indexOf(" on ");

		if (whitespaceOnWhitespaceIndex1 < 0) {
			return false;
		}

		String endingTime = tempString.substring(0, whitespaceOnWhitespaceIndex1);

		if (!Checker.isValidTime(endingTime)) {
			return false;
		}

		tempString = tempString.substring(whitespaceOnWhitespaceIndex1 + 4).trim();

		if (tempString.length() == 0) {
			return false;
		}

		if (tempString.length() == 0) {
			return false;
		}

		String date = tempString.trim();

		if (date.length() == 0) {
			return false;
		}

		if (!Checker.isValidDate(date)) {
			return false;
		}

		return true;

	}

	// check the validity of file storage and/or user input version of a done
	// deadline task
	static boolean isDoneDeadlineTaskInput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceDoneStringIndex = tempString.indexOf(" [done]");

		if (whitespaceDoneStringIndex < 0) {
			return false;
		}

		String afterDoneString = tempString.substring(whitespaceDoneStringIndex + 7).trim();

		if (afterDoneString.length() != 0) {
			return false;
		}

		tempString = tempString.substring(0, whitespaceDoneStringIndex).trim();

		if (tempString.length() == 0) {
			return false;
		}

		if (!Checker.isDeadlineTaskInput(tempString)) {
			return false;
		}

		return true;
	}

	// <taskname>, by <end> on <date>
	static boolean isDeadlineTaskOutput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex1 = tempString.indexOf(DONE_STRING);
		if (doneStringIndex1 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex2 = tempString.indexOf("[done");
		if (doneStringIndex2 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex3 = tempString.indexOf("done]");
		if (doneStringIndex3 >= 0) {
			return false;
		}

		int commaWhitespaceIndex1 = tempString.indexOf(", ");

		if (commaWhitespaceIndex1 <= 0) {
			return false;
		}

		String taskName = tempString.substring(0, commaWhitespaceIndex1).trim();

		if (taskName.length() == 0) {
			return false;
		}

		tempString = tempString.substring(commaWhitespaceIndex1 + 2).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int byWhitespaceIndex1 = tempString.toLowerCase().indexOf("by ");

		if (byWhitespaceIndex1 < 0) {
			return false;
		}

		tempString = tempString.substring(byWhitespaceIndex1 + 3).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceOnWhitespaceIndex1 = tempString.toLowerCase().indexOf(" on ");

		if (whitespaceOnWhitespaceIndex1 < 0) {
			return false;
		}

		String endingTime = tempString.substring(0, whitespaceOnWhitespaceIndex1);

		if (!Checker.isValidTime(endingTime)) {
			return false;
		}

		tempString = tempString.substring(whitespaceOnWhitespaceIndex1 + 4).trim();

		if (tempString.length() == 0) {
			return false;
		}

		if (tempString.length() == 0) {
			return false;
		}

		String date = tempString.trim();

		if (date.length() == 0) {
			return false;
		}

		if (!Checker.isValidDate(date)) {
			return false;
		}

		return true;
	}

	// check the validity of the GUI display of a done deadline task
	// <taskname>, by <end> on <date> [done]
	static boolean isDoneDeadlineTaskOutput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceDoneStringIndex = tempString.indexOf(" [done]");

		if (whitespaceDoneStringIndex < 0) {
			return false;
		}

		String afterDoneString = tempString.substring(whitespaceDoneStringIndex + 7).trim();

		if (afterDoneString.length() != 0) {
			return false;
		}

		tempString = tempString.substring(0, whitespaceDoneStringIndex).trim();

		if (tempString.length() == 0) {
			return false;
		}

		if (!Checker.isDeadlineTaskOutput(tempString)) {
			return false;
		}

		return true;
	}

	// recurring task user input command (not done)
	// <taskname>; <start>-<end> every <day>; priority
	static boolean isRecurringTaskInput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex1 = tempString.indexOf(DONE_STRING);
		if (doneStringIndex1 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex2 = tempString.indexOf("[done");
		if (doneStringIndex2 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex3 = tempString.indexOf("done]");
		if (doneStringIndex3 >= 0) {
			return false;
		}

		int semicolonWhitespaceIndex1 = tempString.indexOf("; ");

		if (semicolonWhitespaceIndex1 <= 0) {
			return false;
		}

		String taskName = tempString.substring(0, semicolonWhitespaceIndex1).trim();

		if (taskName.length() == 0) {
			return false;
		}

		tempString = tempString.substring(semicolonWhitespaceIndex1 + 2).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int dashIndex1 = tempString.indexOf("-");

		if (dashIndex1 < 0) {
			return false;
		}

		String startingTime = tempString.substring(0, dashIndex1).trim();

		if (startingTime.length() != 4) {
			return false;
		}

		if (!isValidTime(startingTime)) {
			return false;
		}

		int startingTimeHours = Integer.valueOf(startingTime.substring(0, 2));
		int startingTimeMinutes = Integer.valueOf(startingTime.substring(2, 4));

		tempString = tempString.substring(dashIndex1 + 1).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceEveryWhitespaceIndex = tempString.toLowerCase().indexOf(" every ");

		if (whitespaceEveryWhitespaceIndex < 0) {
			return false;
		}

		String endingTime = tempString.substring(0, whitespaceEveryWhitespaceIndex);

		if (endingTime.length() != 4) {
			return false;
		}

		if (!isValidTime(endingTime)) {
			return false;
		}

		int endingTimeHours = Integer.valueOf(endingTime.substring(0, 2));
		int endingTimeMinutes = Integer.valueOf(endingTime.substring(2, 4));

		if (endingTimeHours * 60 + endingTimeMinutes < startingTimeHours * 60 + startingTimeMinutes) {
			return false;
		}

		tempString = tempString.substring(whitespaceEveryWhitespaceIndex + 7).trim();

		if (tempString.length() == 0) {
			return false;
		}
		
		String day = tempString.trim();

		// monday, tuesday, wednesday, thursday, friday, saturday, sunday
		if (day.length() == 0) {
			return false;
		}

		if (!Checker.isValidDay(day)) {
			return false;
		}

		return true;
	}

	// recurring task (not done) (GUI Display format)
	// <taskname>, <start>-<end> every <day>, priority
	static boolean isRecurringTaskOutput(String string) {
		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex1 = tempString.indexOf(DONE_STRING);
		if (doneStringIndex1 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex2 = tempString.indexOf("[done");
		if (doneStringIndex2 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex3 = tempString.indexOf("done]");
		if (doneStringIndex3 >= 0) {
			return false;
		}

		int commaWhitespaceIndex1 = tempString.indexOf(", ");

		if (commaWhitespaceIndex1 <= 0) {
			return false;
		}

		String taskName = tempString.substring(0, commaWhitespaceIndex1).trim();

		if (taskName.length() == 0) {
			return false;
		}

		tempString = tempString.substring(commaWhitespaceIndex1 + 2).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int dashIndex1 = tempString.indexOf("-");

		if (dashIndex1 < 0) {
			return false;
		}

		String startingTime = tempString.substring(0, dashIndex1).trim();

		int startingTimeHours = Integer.valueOf(startingTime.substring(0, 2));
		int startingTimeMinutes = Integer.valueOf(startingTime.substring(2, 4));

		if (startingTime.length() != 4) {
			return false;
		}

		if (!isValidTime(startingTime)) {
			return false;
		}

		tempString = tempString.substring(dashIndex1 + 1).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceEveryWhitespaceIndex = tempString.toLowerCase().indexOf(" every ");

		if (whitespaceEveryWhitespaceIndex < 0) {
			return false;
		}

		String endingTime = tempString.substring(0, whitespaceEveryWhitespaceIndex).trim();

		if (endingTime.length() != 4) {
			return false;
		}

		if (!isValidTime(endingTime)) {
			return false;
		}

		int endingTimeHours = Integer.valueOf(endingTime.substring(0, 2));
		int endingTimeMinutes = Integer.valueOf(endingTime.substring(2, 4));

		if (endingTimeHours * 60 + endingTimeMinutes < startingTimeHours * 60 + startingTimeMinutes) {
			return false;
		}

		tempString = tempString.substring(whitespaceEveryWhitespaceIndex + 7).trim();

		if (tempString.length() == 0) {
			return false;
		}

		String day = tempString.trim();

		// monday, tuesday, wednesday, thursday, friday, saturday, sunday
		if (day.length() == 0) {
			return false;
		}

		if (!Checker.isValidDay(day)) {
			return false;
		}

		return true;
	}

	// <taskname>; <start>-<end> on <date>; <priority>
	static boolean isEventTaskInput(String string) {

		String tempString = new String("");
		if (string == null) {
			return false;
		}

		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex1 = tempString.indexOf(DONE_STRING);
		if (doneStringIndex1 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex2 = tempString.indexOf("[done");
		if (doneStringIndex2 >= 0) {
			return false;
		}

		// IMPORTANT: make sure that this task is not marked as done
		int doneStringIndex3 = tempString.indexOf("done]");
		if (doneStringIndex3 >= 0) {
			return false;
		}

		int semicolonWhitespaceIndex1 = tempString.indexOf("; ");

		if (semicolonWhitespaceIndex1 <= 0) {
			return false;
		}

		String taskName = tempString.substring(0, semicolonWhitespaceIndex1).trim();

		if (taskName.length() == 0) {
			return false;
		}

		tempString = tempString.substring(semicolonWhitespaceIndex1 + 2).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int dashIndex1 = tempString.indexOf("-");

		if (dashIndex1 < 0) {
			return false;
		}

		String startingTime = tempString.substring(0, dashIndex1).trim();

		if (startingTime.length() != 4) {
			return false;
		}

		if (!isValidTime(startingTime)) {
			return false;
		}

		int startingTimeHours = Integer.valueOf(startingTime.substring(0, 2));
		int startingTimeMinutes = Integer.valueOf(startingTime.substring(2, 4));

		tempString = tempString.substring(dashIndex1 + 1).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceOnWhitespaceIndex1 = tempString.toLowerCase().indexOf(" on ");

		if (whitespaceOnWhitespaceIndex1 < 0) {
			return false;
		}

		String endingTime = tempString.substring(0, whitespaceOnWhitespaceIndex1).trim();

		if (endingTime.length() != 4) {
			return false;
		}

		if (!Checker.isValidTime(endingTime)) {
			return false;
		}

		int endingTimeHours = Integer.valueOf(endingTime.substring(0, 2));
		int endingTimeMinutes = Integer.valueOf(endingTime.substring(2, 4));

		if (endingTimeHours * 60 + endingTimeMinutes < startingTimeHours * 60 + startingTimeMinutes) {
			return false;
		}

		tempString = tempString.substring(whitespaceOnWhitespaceIndex1 + 4).trim();

		if (tempString.length() == 0) {
			return false;
		}

		int semicolonWhitespaceIndex2 = tempString.indexOf("; ");

		if (semicolonWhitespaceIndex2 < 0) {
			return false;
		}

		String date = tempString.substring(0, semicolonWhitespaceIndex2).trim();

		if (date.length() == 0) {
			return false;
		}

		if (!Checker.isValidDate(date)) {
			return false;
		}

		tempString = tempString.substring(semicolonWhitespaceIndex2 + 2).trim();

		if (tempString.length() == 0) {
			return false;
		}

		String priority = tempString.trim();

		if (priority.length() == 0) {
			return false;
		}

		return true;
	}
    
	static boolean isDoneEventTaskInput(String string) {
		String tempString = new String("");
		if(string==null){
			return false;
		}
		
		tempString = string.trim();

		if (tempString.length() == 0) {
			return false;
		}

		int whitespaceDoneStringIndex = tempString.indexOf(" [done]");

		if (whitespaceDoneStringIndex < 0) {
			return false;
		}

		String afterDoneString = tempString.substring(whitespaceDoneStringIndex + 7).trim();

		if (afterDoneString.length() != 0) {
			return false;
		}

		tempString = tempString.substring(0, whitespaceDoneStringIndex).trim();

		if (tempString.length() == 0) {
			return false;
		}

		if (!Checker.isEventTaskInput(tempString)) {
			return false;
		}

		return true;
	}
    
```
###### src\CRUD.java
``` java

import java.util.*;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.logging.*;

public class CRUD {
	private static final Logger logger = Logger.getLogger(CRUD.class.getName());

	private static final String NOTHING_TO_UNDO_MESSAGE = "Nothing to undo as no valid previous command.";
	private static final String DELETED_MESSAGE = "The specified task has been deleted.";
	private static final String ADDED_MESSAGE = "The task has been successfully added.";
	private static final String CHANGED_MESSAGE = "(The change to the task information is valid and processed.)";
	private static final String CHANGE_UNDONE_MESSAGE = "The last valid change action has been undone.";
	private static final String DELETE_UNDONE_MESSAGE = "The last valid delete action has been undone.";
	private static final String ADD_UNDONE_MESSAGE = "The last valid add action has been undone.";
	private static final String INVALID_INPUT_MESSAGE = "Invalid command. Please try again.";
	private static final String MARKED_DONE_OR_NOT_DONE_MESSAGE = "The task has been marked as done/not done.";
	private static final String TASK_DOES_NOT_EXIST_MESSAGE = "Task does not exist.";
	private static final String BLOCKED_MESSAGE = "Unable to add the new event task, because of clashes with existing event tasks.";
	private static final String CLEAR_UNDONE_MESSAGE = "The clearing of the file has been undone.";
	private static final String UNCLEAR_UNDONE_MESSAGE = "The unclearing of the file has been undone.";
	private static final String CLEAR_MESSAGE = "The file has been cleared.";

	private static final int HOUR_MINUTES = 60;

	// deletes a task
	static String deleteTask(String filename, String remainingString, LastAction lastAction) throws IOException {
		// reads in the file, line by line
		boolean taskExists = false;

		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;
		ArrayList<Task> allTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {

				allTasksList.add(new Task(currentLine));
			}

		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();
		ArrayList<Task> floatingTasksList = new ArrayList<Task>();
		ArrayList<Task> recurringTasksList = new ArrayList<Task>();

		for (int j = 0; j < allTasksList.size(); j++) {
			if (Checker.isDeadlineTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneDeadlineTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isEventTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneEventTaskInput(allTasksList.get(j).getScheduleString())) {
				deadlineOrEventTasksList.add(allTasksList.get(j));
			} else if (Checker.isFloatingTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneFloatingTaskInput(allTasksList.get(j).getScheduleString())) {
				floatingTasksList.add(allTasksList.get(j));
			} else if (Checker.isRecurringTaskInput(allTasksList.get(j).getScheduleString())) {
				recurringTasksList.add(allTasksList.get(j));
			}
		}

		Task tempTask = new Task();

		String tempString = new String("");

		tempString = remainingString.trim();

		if (tempString.length() <= 0) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
		}

		int whitespaceIndex1 = tempString.indexOf(" ");
		if (whitespaceIndex1 < 0) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();

			return INVALID_INPUT_MESSAGE;
		}

		String deleteVariableType = new String("");
		deleteVariableType = tempString.substring(0, whitespaceIndex1).trim();

		tempString = tempString.substring(whitespaceIndex1 + 1).trim();

		if (tempString.length() <= 0) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();

			return INVALID_INPUT_MESSAGE;
		}

		if (deleteVariableType.equalsIgnoreCase("floating")) {
			// delete floating <number>
			// for floating tasks

			String tempNumber = tempString.trim();

			char[] charArray = new char[tempNumber.length()];
			tempNumber.getChars(0, tempNumber.length(), charArray, 0);

			boolean isNumberValid = true;

			for (int b = 0; b < tempNumber.length(); b++) {
				if (!Character.isDigit(charArray[b])) {
					isNumberValid = false;
				}
			}

			if (!isNumberValid) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return INVALID_INPUT_MESSAGE;
			}

			if (Integer.valueOf(tempNumber) <= 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return INVALID_INPUT_MESSAGE;
			}

			if (Integer.valueOf(tempNumber) > floatingTasksList.size()) {
				FlexWindow.getFeedback().appendText(TASK_DOES_NOT_EXIST_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(TASK_DOES_NOT_EXIST_MESSAGE);
				System.out.println(TASK_DOES_NOT_EXIST_MESSAGE);
				System.out.println();

				return TASK_DOES_NOT_EXIST_MESSAGE;
			}

			tempTask = allTasksList.get(deadlineOrEventTasksList.size() + Integer.valueOf(tempNumber) - 1);

			lastAction.setPreviousTask(tempTask);
			lastAction.setPreviousAction("delete");
			lastAction.setPreviousChangedScheduleString(null);

			allTasksList.remove(deadlineOrEventTasksList.size() + Integer.valueOf(tempNumber) - 1);

			taskExists = true;

		} else if (deleteVariableType.equalsIgnoreCase("rec")) {
			// delete rec <number>
			// for recurring tasks

			String tempNumber = tempString.trim();

			char[] charArray1 = new char[tempNumber.length()];
			tempNumber.getChars(0, tempNumber.length(), charArray1, 0);

			boolean isNumberValid = true;

			for (int c = 0; c < tempNumber.length(); c++) {
				if (!Character.isDigit(charArray1[c])) {
					isNumberValid = false;
				}
			}

			if (!isNumberValid) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return INVALID_INPUT_MESSAGE;
			}

			if (Integer.valueOf(tempNumber) <= 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return INVALID_INPUT_MESSAGE;
			}

			if (Integer.valueOf(tempNumber) > recurringTasksList.size()) {
				FlexWindow.getFeedback().appendText(TASK_DOES_NOT_EXIST_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(TASK_DOES_NOT_EXIST_MESSAGE);
				System.out.println(TASK_DOES_NOT_EXIST_MESSAGE);
				System.out.println();

				return TASK_DOES_NOT_EXIST_MESSAGE;
			}

			tempTask = allTasksList
					.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(tempNumber) - 1);

			lastAction.setPreviousTask(tempTask);

			lastAction.setPreviousAction("delete");

			allTasksList.remove(
					deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(tempNumber) - 1);

			taskExists = true;

		} else if (Checker.isValidDate(deleteVariableType)) {
			// delete <date> <number>
			// for deadline and event tasks

			assert (Checker.isValidDate(deleteVariableType));

			String date = deleteVariableType.trim();

			String tempNumber = tempString.trim();

			char[] charArray2 = new char[tempNumber.length()];
			tempNumber.getChars(0, tempNumber.length(), charArray2, 0);

			boolean isNumberValid = true;

			for (int d = 0; d < tempNumber.length(); d++) {
				if (!Character.isDigit(charArray2[d])) {
					isNumberValid = false;
				}
			}

			if (!isNumberValid) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return INVALID_INPUT_MESSAGE;
			}

			if (Integer.valueOf(tempNumber) <= 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return INVALID_INPUT_MESSAGE;
			}

			if (Integer.valueOf(tempNumber) > deadlineOrEventTasksList.size()) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(TASK_DOES_NOT_EXIST_MESSAGE);
				System.out.println(TASK_DOES_NOT_EXIST_MESSAGE);
				System.out.println();

				return TASK_DOES_NOT_EXIST_MESSAGE;
			}

			int counterIndex = 0;

			for (int r = 0; r < allTasksList.size(); r++) {
				if (Checker.isDeadlineTaskInput(allTasksList.get(r).getScheduleString())
						|| Checker.isDoneDeadlineTaskInput(allTasksList.get(r).getScheduleString())
						|| Checker.isEventTaskInput(allTasksList.get(r).getScheduleString())
						|| Checker.isDoneEventTaskInput(allTasksList.get(r).getScheduleString())) {
					if (allTasksList.get(r).getDate().equalsIgnoreCase(date)) {
						counterIndex += 1;

						if (counterIndex == Integer.valueOf(tempNumber)) {
							tempTask = allTasksList.get(r);
							lastAction.setPreviousTask(tempTask);
							lastAction.setPreviousAction("delete");

							allTasksList.remove(r);
							taskExists = true;
						}
					}
				}
			}

		} else {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();

			return INVALID_INPUT_MESSAGE;
		}

		if (taskExists == false) {
			FlexWindow.getFeedback().appendText(TASK_DOES_NOT_EXIST_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(TASK_DOES_NOT_EXIST_MESSAGE);
			System.out.println(TASK_DOES_NOT_EXIST_MESSAGE);
			System.out.println();

			return TASK_DOES_NOT_EXIST_MESSAGE;
		}

		// sort all tasks by date and starting time
		SortAndShow.sortAllTasksByDateAndStartingTime(allTasksList);

		// overwrites to the file, line by line
		BufferedWriter writer = new BufferedWriter(new FileWriter(filename));

		for (int i = 0; i < allTasksList.size(); i++) {
			writer.write(allTasksList.get(i).getScheduleString());
			writer.newLine();
		}

		writer.close();

		FlexWindow.getFeedback().appendText(DELETED_MESSAGE + "\n");
		FlexWindow.getFeedback().appendText("\n");

		logger.finest(DELETED_MESSAGE);
		System.out.println(DELETED_MESSAGE);
		System.out.println();

		return DELETED_MESSAGE;
	}

	// changes one of the variables in a task, EXCEPT for the comparison value
	// for sorting all tasks by date and starting time
	// Case 7: changing a task's variable
	// each change/edit command starts with the hyphen on the far left

	// For Editing An Event Task

	// change <date> <number> to <newdate>
	// change <date> <number> priority to <newpriority>
	// change <date> <number> time to <newstart>-<newend>
	// change <date> <number> taskname to <newtaskname>

	// For Editing A Deadline Task
	// change <date> <number> to <newdate>
	// change <date> <number> end by <new end>
	// change <date> <number> by <newend> on <newdate>
	// change <date> <number> taskname to <newtaskname>

	// For Editing A Recurring Task
	// change rec <number> to every <newday>
	// change rec <number> time to <newstart>-<newend>
	// change rec <number> taskname to <newtaskname>

	// For Editing A Floating Task
	// change floating <number> taskname to <newtaskname>

	static String changeTaskVariable(String filename, String remainingCommandString, LastAction lastAction)
			throws IOException {

		String tempString = new String("");
		tempString = remainingCommandString.trim();

		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;
		ArrayList<Task> allTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {

				allTasksList.add(new Task(currentLine));
			}

		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();
		ArrayList<Task> floatingTasksList = new ArrayList<Task>();
		ArrayList<Task> recurringTasksList = new ArrayList<Task>();

		for (int j = 0; j < allTasksList.size(); j++) {
			if (Checker.isDeadlineTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneDeadlineTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isEventTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneEventTaskInput(allTasksList.get(j).getScheduleString())) {
				deadlineOrEventTasksList.add(allTasksList.get(j));
			} else if (Checker.isFloatingTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneFloatingTaskInput(allTasksList.get(j).getScheduleString())) {
				floatingTasksList.add(allTasksList.get(j));
			} else if (Checker.isRecurringTaskInput(allTasksList.get(j).getScheduleString())) {
				recurringTasksList.add(allTasksList.get(j));
			}
		}

		int whitespaceIndex1 = tempString.indexOf(" ");
		if (whitespaceIndex1 < 0) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();
			return INVALID_INPUT_MESSAGE;
		}

		String firstTerm = tempString.substring(0, whitespaceIndex1).trim();

		tempString = tempString.substring(whitespaceIndex1 + 1).trim();

		if (tempString.length() == 0) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();
			return INVALID_INPUT_MESSAGE;
		}

		if (Checker.isValidDate(firstTerm)) {
			// CASE 1: for a deadline task or an event task

			assert (Checker.isValidDate(firstTerm));

			String date = firstTerm.trim();

			int whitespaceIndex2 = tempString.indexOf(" ");
			if (whitespaceIndex2 < 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			String number1 = tempString.substring(0, whitespaceIndex2).trim();
			char[] charArray1 = new char[number1.length()];
			number1.getChars(0, number1.length(), charArray1, 0);

			boolean isNumber4 = true;

			for (int c = 0; c < number1.length(); c++) {
				if (!Character.isDigit(charArray1[c])) {
					isNumber4 = false;
				}
			}

			if (!isNumber4) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			int taskCountForDate = 0;
			int firstTaskForDateIndex = -1;
			// e.g. firstTaskForDateIndex is 10
			// and taskCountForDate is 3 (index 10, index 11, index 12)
			// and the given number is 2
			// then the index of the task to have its information changed is
			// equal to 11
			// which is calculated as
			// firstTaskForDateIndex + Integer.valueOf(number1) - 1
			// = 10 + 2 - 1 = 11

			for (int i = 0; i < deadlineOrEventTasksList.size(); i++) {
				if (allTasksList.get(i).getDate().equalsIgnoreCase(date)) {
					firstTaskForDateIndex = i;
					break;
				}
			}

			for (int i = 0; i < deadlineOrEventTasksList.size(); i++) {
				if (allTasksList.get(i).getDate().equalsIgnoreCase(date)) {
					taskCountForDate += 1;
				}
			}

			if (firstTaskForDateIndex < 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			if ((Integer.valueOf(number1) <= 0) || (Integer.valueOf(number1) > taskCountForDate)) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			tempString = tempString.substring(whitespaceIndex2 + 1).trim();

			if (tempString.length() == 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			int tasknameWhitespaceToIndex2 = tempString.indexOf("taskname to ");
			int dateWhitespaceToIndex2 = tempString.indexOf("date to ");
			int timeWhitespaceToIndex2 = tempString.indexOf("time to ");
			int endWhitespaceByIndex2 = tempString.indexOf("end by ");
			int byIndex2 = tempString.indexOf("by ");
			int priorityToIndex2 = tempString.indexOf("priority to ");

			if (priorityToIndex2 == 0) {
				tempString = tempString.substring(priorityToIndex2 + 12).trim();

				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String newPriority = tempString.trim();

				String taskBeforeChange = allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1)
						.getScheduleString();

				// the task must to be changed should be an event task
				if (!(Checker.isEventTaskInput(taskBeforeChange) || Checker.isDoneEventTaskInput(taskBeforeChange))) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setPriority(newPriority);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(
						allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getScheduleString()));

			} else if (tasknameWhitespaceToIndex2 == 0) {
				tempString = tempString.substring(tasknameWhitespaceToIndex2 + 12).trim();

				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String newTaskName = tempString.trim();
				String taskBeforeChange = allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1)
						.getScheduleString();

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setTaskName(newTaskName);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(
						allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getScheduleString()));

			} else if (dateWhitespaceToIndex2 == 0) {
				tempString = tempString.substring(dateWhitespaceToIndex2 + 8).trim();

				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String newDate = tempString.trim();

				if (!Checker.isValidDate(newDate)) {

					assert (!Checker.isValidDate(newDate));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1)
						.getScheduleString();

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setDate(newDate);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(
						allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getScheduleString()));

			} else if (timeWhitespaceToIndex2 == 0) {

				System.out.println("EVENT TIME TO ");
				
				tempString = tempString.substring(timeWhitespaceToIndex2 + 8).trim();

				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				int hyphenIndex3 = tempString.indexOf("-");

				if (hyphenIndex3 < 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String startingTime = tempString.substring(0, hyphenIndex3).trim();

				System.out.println("startingTime:" + startingTime);
				
				
				if (startingTime.length() != 4) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (!Checker.isValidTime(startingTime)) {

					assert (!Checker.isValidTime(startingTime));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String endingTime = tempString.substring(hyphenIndex3 + 1).trim();

				System.out.println("endingTime:" + endingTime);
				
				if (endingTime.length() != 4) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (!Checker.isValidTime(endingTime)) {

					assert (!Checker.isValidTime(endingTime));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				int endTimeHours = Integer.valueOf(endingTime.substring(0, 2));
				int endTimeMinutes = Integer.valueOf(endingTime.substring(2, 4));
				int totalEndTime = endTimeHours * HOUR_MINUTES + endTimeMinutes;
				int startTimeHours = Integer.valueOf(startingTime.substring(0, 2));
				int startTimeMinutes = Integer.valueOf(startingTime.substring(2, 4));
				int totalStartTime = startTimeHours * HOUR_MINUTES + startTimeMinutes;

				System.out.println("totalEndTime:" + totalEndTime);
				System.out.println("totalStartTime:" + totalStartTime);
				
				if (totalEndTime < totalStartTime) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1)
						.getScheduleString();

				// the task must to be changed should be an event task
				if (!(Checker.isEventTaskInput(taskBeforeChange) || Checker.isDoneEventTaskInput(taskBeforeChange))) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setStart("0000");

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setEnd(endingTime);

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setStart(startingTime);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(
						allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getScheduleString()));

			} else if (endWhitespaceByIndex2 == 0) {
				tempString = tempString.substring(endWhitespaceByIndex2 + 7).trim();

				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String newEndingTime = tempString.trim();

				if (!Checker.isValidTime(newEndingTime)) {

					assert (!Checker.isValidTime(newEndingTime));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1)
						.getScheduleString();

				// the task to be changed should be a deadline task
				if (!(Checker.isDeadlineTaskInput(taskBeforeChange)
						|| Checker.isDoneDeadlineTaskInput(taskBeforeChange))) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setEnd(newEndingTime);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(
						allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getScheduleString()));

			} else if (byIndex2 == 0) {
				tempString = tempString.substring(byIndex2 + 3).trim();
				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				int whitespaceOnWhitespaceIndex1 = tempString.indexOf(" on ");

				if (whitespaceOnWhitespaceIndex1 < 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String newEndingTime6 = tempString.substring(0, whitespaceOnWhitespaceIndex1).trim();

				if (newEndingTime6.length() != 4) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (!Checker.isValidTime(newEndingTime6)) {

					assert (!Checker.isValidTime(newEndingTime6));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String newDate2 = tempString.substring(whitespaceOnWhitespaceIndex1 + 4).trim();

				if (newDate2.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (!Checker.isValidDate(newDate2)) {

					assert (!Checker.isValidDate(newDate2));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1)
						.getScheduleString();

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setEnd(newEndingTime6);

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setDate(newDate2);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(
						allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getScheduleString()));

			} else {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}
		} else if (firstTerm.equalsIgnoreCase("floating")) {
			// For editing a floating task
			// change floating <number> done

			int whitespaceIndex3 = tempString.indexOf(" ");
			if (whitespaceIndex3 < 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			String number2 = tempString.substring(0, whitespaceIndex3).trim();
			char[] charArray1 = new char[number2.length()];
			number2.getChars(0, number2.length(), charArray1, 0);

			boolean isNumber2 = true;

			for (int c = 0; c < number2.length(); c++) {
				if (!Character.isDigit(charArray1[c])) {
					isNumber2 = false;
				}
			}

			if (!isNumber2) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			if ((Integer.valueOf(number2) <= 0) || (Integer.valueOf(number2) > floatingTasksList.size())) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			tempString = tempString.substring(whitespaceIndex3 + 1).trim();

			if (tempString.length() == 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			int tasknameWhitespaceToIndex3 = tempString.indexOf("taskname to ");

			if (tasknameWhitespaceToIndex3 == 0) {
				tempString = tempString.substring(tasknameWhitespaceToIndex3 + 12).trim();

				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String newTaskName = tempString.trim();
				String taskBeforeChange = allTasksList
						.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1).getScheduleString();

				allTasksList.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1)
						.setTaskName(newTaskName);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(allTasksList
						.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1).getScheduleString()));

			} else {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

		} else if (firstTerm.equalsIgnoreCase("rec")) {
			// For Editing A Recurring Task
			// change rec <number> to every <newday>
			// change rec <number> time to <newstart>-<newend>
			// change rec <number> taskname to <newtaskname>

			int whitespaceIndex2 = tempString.indexOf(" ");
			if (whitespaceIndex2 < 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			String number1 = tempString.substring(0, whitespaceIndex2).trim();
			char[] charArray1 = new char[number1.length()];
			number1.getChars(0, number1.length(), charArray1, 0);

			boolean isNumber1 = true;

			for (int c = 0; c < number1.length(); c++) {
				if (!Character.isDigit(charArray1[c])) {
					isNumber1 = false;
				}
			}

			if (!isNumber1) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			if ((Integer.valueOf(number1) <= 0) || (Integer.valueOf(number1) > recurringTasksList.size())) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			tempString = tempString.substring(whitespaceIndex2 + 1).trim();

			if (tempString.length() == 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			int tasknameWhitespaceToIndex5 = tempString.indexOf("taskname to ");
			int toWhitespaceEveryWhitespaceIndex1 = tempString.indexOf("to every ");
			int timeWhitespaceToWhitespaceIndex1 = tempString.indexOf("time to ");

			if (tasknameWhitespaceToIndex5 == 0) {
				tempString = tempString.substring(tasknameWhitespaceToIndex5 + 12).trim();

				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String newTaskName = tempString.trim();
				String taskBeforeChange = allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.getScheduleString();

				allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.setTaskName(newTaskName);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.getScheduleString()));

			} else if (toWhitespaceEveryWhitespaceIndex1 == 0) {
				tempString = tempString.substring(toWhitespaceEveryWhitespaceIndex1 + 9).trim();
				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (!Checker.isValidDay(tempString)) {

					assert (!Checker.isValidDay(tempString));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String day = tempString.trim();

				String taskBeforeChange = allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.getScheduleString();

				allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.setDay(day.toLowerCase());

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.getScheduleString()));

			} else if (timeWhitespaceToWhitespaceIndex1 == 0) {

				tempString = tempString.substring(timeWhitespaceToWhitespaceIndex1 + 8).trim();

				if (tempString.length() == 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				int hyphenIndex1 = tempString.indexOf("-");

				if (hyphenIndex1 < 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");
					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String startTime = tempString.substring(0, hyphenIndex1).trim();

				if (startTime.length() != 4) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (!Checker.isValidTime(startTime)) {

					assert (!Checker.isValidTime(startTime));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String endTime = tempString.substring(hyphenIndex1 + 1).trim();

				if (endTime.length() != 4) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (!Checker.isValidTime(endTime)) {

					assert (!Checker.isValidTime(endTime));

					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				int startTimeHours = Integer.valueOf(startTime.substring(0, 2).trim());
				int startTimeMinutes = Integer.valueOf(startTime.substring(2, 4).trim());
				int totalStartTime = startTimeHours * HOUR_MINUTES + startTimeMinutes;
				int endTimeHours = Integer.valueOf(endTime.substring(0, 2).trim());
				int endTimeMinutes = Integer.valueOf(endTime.substring(2, 4).trim());
				int totalEndTime = endTimeHours * HOUR_MINUTES + endTimeMinutes;

				if (totalEndTime < totalStartTime) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.getScheduleString();

				// set the end time first, then the start time, as tasks are
				// checked for starting time
				// being less than or equal to end time. Not following this
				// order WILL crash the program
				allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.setStart("0000");

				allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.setEnd(endTime);
				allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.setStart(startTime);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(allTasksList
						.get(deadlineOrEventTasksList.size() + floatingTasksList.size() + Integer.valueOf(number1) - 1)
						.getScheduleString()));

			} else {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

		} else {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();
			return INVALID_INPUT_MESSAGE;
		}

		// sort all tasks by date and starting time
		SortAndShow.sortAllTasksByDateAndStartingTime(allTasksList);

		// overwrites to the file, line by line
		BufferedWriter writer = new BufferedWriter(new FileWriter(filename));

		for (int i = 0; i < allTasksList.size(); i++) {
			writer.write(allTasksList.get(i).getScheduleString());
			writer.newLine();
		}

		writer.close();

		FlexWindow.getFeedback().appendText(CHANGED_MESSAGE + "\n");
		FlexWindow.getFeedback().appendText("\n");

		logger.finest(CHANGED_MESSAGE);
		System.out.println(CHANGED_MESSAGE);
		System.out.println();

		return CHANGED_MESSAGE;

	}

	// adds a task
	static String addTask(String filename, String remainingCommandString, LastAction lastAction) throws IOException {
		String remainingCommandString1 = remainingCommandString.trim();

		// reads in the file, line by line
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {

				allTasksList.add(new Task(currentLine));

			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		// check for the validity of the potential Task's variables,
		// and print out error messages for only the first mistake made by the
		// user,
		// for the Task String
		boolean isAddedTaskValid = (Checker.isFloatingTaskInput(remainingCommandString1)
				|| Checker.isDoneFloatingTaskInput(remainingCommandString1)
				|| Checker.isDeadlineTaskInput(remainingCommandString1)
				|| Checker.isDoneDeadlineTaskInput(remainingCommandString1)
				|| Checker.isEventTaskInput(remainingCommandString1)
				|| Checker.isDoneEventTaskInput(remainingCommandString1)
				|| Checker.isRecurringTaskInput(remainingCommandString1));

		// if the task is not valid, do not continue the process of adding a
		// task
		if (!isAddedTaskValid) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();

			return INVALID_INPUT_MESSAGE;
		}
		Task temporaryTask = new Task(remainingCommandString1);

		// Checks for clashes between new event task which is added,
		// and existing tasks
		// Multi-tasking is still allowed - same date, same starting time and
		// same ending time.
		if (Checker.isEventTaskInput(remainingCommandString1)
				|| Checker.isDoneEventTaskInput(remainingCommandString1)) {

			int startingTimeHours = Integer.valueOf(temporaryTask.getStart().substring(0, 2).trim());
			int startingTimeMinutes = Integer.valueOf(temporaryTask.getStart().substring(2, 4).trim());
			int totalStartingTime = startingTimeHours * HOUR_MINUTES + startingTimeMinutes;

			int endingTimeHours = Integer.valueOf(temporaryTask.getEnd().substring(0, 2).trim());
			int endingTimeMinutes = Integer.valueOf(temporaryTask.getEnd().substring(2, 4).trim());
			int totalEndingTime = endingTimeHours * HOUR_MINUTES + endingTimeMinutes;

			for (int w = 0; w < allTasksList.size(); w++) {
				if ((Checker.isEventTaskInput(allTasksList.get(w).getScheduleString())
						|| Checker.isDoneEventTaskInput(allTasksList.get(w).getScheduleString()))
						&& (allTasksList.get(w).getDate() != null)
						&& (allTasksList.get(w).getDate().equalsIgnoreCase(temporaryTask.getDate()))) {

					int existingStartingTimeHours = Integer
							.valueOf(allTasksList.get(w).getStart().substring(0, 2).trim());
					int existingStartingTimeMinutes = Integer
							.valueOf(allTasksList.get(w).getStart().substring(2, 4).trim());
					int existingTotalStartingTime = existingStartingTimeHours * HOUR_MINUTES
							+ existingStartingTimeMinutes;

					int existingEndingTimeHours = Integer.valueOf(allTasksList.get(w).getEnd().substring(0, 2).trim());
					int existingEndingTimeMinutes = Integer
							.valueOf(allTasksList.get(w).getEnd().substring(2, 4).trim());
					int existingTotalEndingTime = existingEndingTimeHours * HOUR_MINUTES + existingEndingTimeMinutes;

					if ((totalStartingTime > existingTotalStartingTime) && (totalStartingTime < existingTotalEndingTime)
							|| ((totalEndingTime > existingTotalStartingTime)
									&& (totalEndingTime < existingTotalEndingTime))) {
						FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
						FlexWindow.getFeedback().appendText("\n");

						logger.finest(INVALID_INPUT_MESSAGE);
						System.out.println(INVALID_INPUT_MESSAGE);
						System.out.println();

						FlexWindow.getFeedback().appendText(BLOCKED_MESSAGE + "\n");
						FlexWindow.getFeedback().appendText("\n");

						logger.finest(BLOCKED_MESSAGE);
						System.out.println(BLOCKED_MESSAGE);
						System.out.println();

						return BLOCKED_MESSAGE;

					}

				}
			}
		}

		allTasksList.add(new Task(remainingCommandString1));

		Task tempTask = allTasksList.get(allTasksList.size() - 1);

		// sort all tasks by date and starting time
		SortAndShow.sortAllTasksByDateAndStartingTime(allTasksList);

		// overwrites to the file, line by line
		BufferedWriter writer = new BufferedWriter(new FileWriter(filename));

		for (int i = 0; i < allTasksList.size(); i++) {
			writer.write(allTasksList.get(i).getScheduleString());
			writer.newLine();
		}

		writer.close();

		logger.finest(ADDED_MESSAGE);
		System.out.println(ADDED_MESSAGE);
		System.out.println();

		lastAction.setPreviousAction("add");
		lastAction.setPreviousTask(tempTask);
		lastAction.setPreviousChangedScheduleString(null);

		FlexWindow.getFeedback()
				.appendText("The task " + "\"" + tempTask.getDisplayString() + "\"" + " has been added." + "\n");
		FlexWindow.getFeedback().appendText("\n");

		return "The task " + "\"" + tempTask.getDisplayString() + "\"" + " has been added." + "\n";
	}

	// undo the previous VALID action, only if the previous action was adding a
	// task,
	// deleting a task,
	// or changing a task's variable
	// This is because there is no need to undo a search task
	static String undo(String filename, LastAction lastAction) throws IOException, NullPointerException {

		if (lastAction.getPreviousAction() == null || lastAction.getPreviousTask() == null) {
			FlexWindow.getFeedback().appendText(NOTHING_TO_UNDO_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(NOTHING_TO_UNDO_MESSAGE);
			System.out.println(NOTHING_TO_UNDO_MESSAGE);
			System.out.println();

			return NOTHING_TO_UNDO_MESSAGE;
		}

		int whitespaceIndex1 = lastAction.getPreviousAction().trim().indexOf(" ");

		if (whitespaceIndex1 < 0) {

			if (lastAction.getPreviousAction().equalsIgnoreCase("add")) {
				// undo add

				BufferedReader reader = null;

				reader = new BufferedReader(new FileReader(filename));
				String currentLine = null;

				ArrayList<Task> allTasksListUNDOADD = new ArrayList<Task>();

				do {
					currentLine = reader.readLine();
					if (currentLine != null) {

						allTasksListUNDOADD.add(new Task(currentLine));
					}
				} while (currentLine != null);

				if (reader != null) {
					reader.close();
				}

				Task tempTask = new Task();

				// for exactness, equalsIgnoreCase is not used
				for (int i = 0; i < allTasksListUNDOADD.size(); i++) {
					if (lastAction.getPreviousTask().getScheduleString()
							.equals(allTasksListUNDOADD.get(i).getScheduleString())) {
						tempTask = allTasksListUNDOADD.get(i);
						allTasksListUNDOADD.remove(i);
						lastAction.setPreviousAction("delete");
						lastAction.setPreviousTask(tempTask);
						lastAction.setPreviousChangedScheduleString(null);
						break;
					}
				}

				// sort all tasks by date and starting time
				SortAndShow.sortAllTasksByDateAndStartingTime(allTasksListUNDOADD);

				BufferedWriter writer = new BufferedWriter(new FileWriter(filename));

				for (int j = 0; j < allTasksListUNDOADD.size(); j++) {
					writer.write(allTasksListUNDOADD.get(j).getScheduleString());
					writer.newLine();
				}

				writer.close();

				logger.finest(ADD_UNDONE_MESSAGE);
				System.out.println(ADD_UNDONE_MESSAGE);
				System.out.println();

				FlexWindow.getFeedback().appendText(ADD_UNDONE_MESSAGE);
				FlexWindow.getFeedback().appendText("\n");

				return ADD_UNDONE_MESSAGE;

			} else if (lastAction.getPreviousAction().equalsIgnoreCase("delete")) {
				// undo delete

				CRUD.addTask(filename, lastAction.getPreviousTask().getScheduleString(), lastAction);

				logger.finest(DELETE_UNDONE_MESSAGE);
				System.out.println(DELETE_UNDONE_MESSAGE);
				System.out.println();

				FlexWindow.getFeedback().appendText(DELETE_UNDONE_MESSAGE);
				FlexWindow.getFeedback().appendText("\n");

				return DELETE_UNDONE_MESSAGE;

			} else if (lastAction.getPreviousAction().trim().equalsIgnoreCase("change")) {
				// undo change

				String taskBeforeChange = lastAction.getPreviousChangedScheduleString();

				String taskAfterChange = lastAction.getPreviousTask().getScheduleString();

				// reads in the file, line by line
				BufferedReader reader = null;

				reader = new BufferedReader(new FileReader(filename));
				String currentLine = null;

				ArrayList<Task> allTasksListUNDOCHANGE = new ArrayList<Task>();

				do {
					currentLine = reader.readLine();
					if (currentLine != null) {

						allTasksListUNDOCHANGE.add(new Task(currentLine));
					}
				} while (currentLine != null);

				if (reader != null) {
					reader.close();
				}

				// for exactness, equalsIgnoreCase is not used
				for (int i = 0; i < allTasksListUNDOCHANGE.size(); i++) {
					if (taskAfterChange.equals(allTasksListUNDOCHANGE.get(i).getScheduleString())) {
						allTasksListUNDOCHANGE.remove(i);
						break;
					}
				}

				SortAndShow.sortAllTasksByDateAndStartingTime(allTasksListUNDOCHANGE);

				BufferedWriter writer = new BufferedWriter(new FileWriter(filename));

				for (int j = 0; j < allTasksListUNDOCHANGE.size(); j++) {
					writer.write(allTasksListUNDOCHANGE.get(j).getScheduleString());
					writer.newLine();
				}

				writer.close();

				CRUD.addTask(filename, taskBeforeChange, lastAction);

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskAfterChange);
				lastAction.setPreviousTask(new Task(taskBeforeChange));

				logger.finest(CHANGE_UNDONE_MESSAGE);
				System.out.println(CHANGE_UNDONE_MESSAGE);
				System.out.println();

				FlexWindow.getFeedback().appendText(CHANGE_UNDONE_MESSAGE);
				FlexWindow.getFeedback().appendText("\n");

				return CHANGE_UNDONE_MESSAGE;

			} else if (lastAction.getPreviousAction().trim().equalsIgnoreCase("clear")) {
				// undo clear

				BufferedWriter writer = new BufferedWriter(new FileWriter(filename));

				for (int z = 0; z < lastAction.getClearTaskList().size(); z++) {
					writer.write(lastAction.getClearTaskList().get(z).getScheduleString());
					writer.newLine();
				}

				writer.close();

				lastAction.setPreviousAction("unclear");
				lastAction.setClearTaskList(lastAction.getClearTaskList());

				FlexWindow.getFeedback().appendText(CLEAR_UNDONE_MESSAGE);
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(CLEAR_UNDONE_MESSAGE);
				System.out.println(CLEAR_UNDONE_MESSAGE);
				System.out.println();

				return CLEAR_UNDONE_MESSAGE;

			} else if (lastAction.getPreviousAction().trim().equalsIgnoreCase("unclear")) {
				// undo an undone clear

				CRUD.clear(filename, lastAction);

				FlexWindow.getFeedback().appendText(UNCLEAR_UNDONE_MESSAGE);
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(UNCLEAR_UNDONE_MESSAGE);
				System.out.println(UNCLEAR_UNDONE_MESSAGE);
				System.out.println();

				return UNCLEAR_UNDONE_MESSAGE;
			}
		}

		return NOTHING_TO_UNDO_MESSAGE;
	}

	// mark a deadline, event or floating task
	// as done or not done
```
###### src\FlexIntegrationTest.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexIntegrationTest.java
// tests the functionality of some of the main methods in the program
// using unit-testing

// The .txt file under test
// is called FlexIntegrationTestDocument.txt

public class FlexIntegrationTest {

	private static final String ALL_TASKS_DISPLAYED_MESSAGE = "All the tasks in the schedule are displayed.";
	private static final String NOTHING_TO_UNDO_MESSAGE = "Nothing to undo as no valid previous command.";
	private static final String DELETED_MESSAGE = "The specified task has been deleted.";
	private static final String CHANGED_MESSAGE = "(The change to the task information is valid and processed.)";
	private static final String CHANGE_UNDONE_MESSAGE = "The last valid change action has been undone.";
	private static final String DELETE_UNDONE_MESSAGE = "The last valid delete action has been undone.";
	private static final String ADD_UNDONE_MESSAGE = "The last valid add action has been undone.";
	private static final String INVALID_INPUT_MESSAGE = "Invalid command. Please try again.";
	private static final String MARKED_DONE_OR_NOT_DONE_MESSAGE = "The task has been marked as done/not done.";
	private static final String TASK_DOES_NOT_EXIST_MESSAGE = "Task does not exist.";
	private static final String BLOCKED_MESSAGE = "Unable to add the new event task, because of clashes with existing event tasks.";
	
	@Test
	public void test() throws IOException {
		String filename = "FlexIntegrationTestDocument.txt";
	
		String[] args = new String[100];
		
		FlexWindow.main(args);
		
		LastAction lastAction = new LastAction();

		String remainingCommandString = new String("");

		remainingCommandString = "change floating 1 taskname to Go to school on every weekday";

		// CRUD.undo() - undoing nothing

		assertEquals("undoing nothing", NOTHING_TO_UNDO_MESSAGE, CRUD.undo(filename, lastAction));

		assertEquals("undoing nothing", NOTHING_TO_UNDO_MESSAGE, CRUD.undo(filename, lastAction));

		// CRUD.changeTaskVariable();
		assertEquals("changing a task", INVALID_INPUT_MESSAGE,
				CRUD.changeTaskVariable(filename, remainingCommandString, lastAction));

		remainingCommandString = "floating 1 taskname to Go to school on every weekday";

		assertEquals("changing a task", CHANGED_MESSAGE,
				CRUD.changeTaskVariable(filename, remainingCommandString, lastAction));

		// CRUD.deleteTask();
		remainingCommandString = "floating ";

		assertEquals("deleting a task", INVALID_INPUT_MESSAGE,
				CRUD.deleteTask(filename, remainingCommandString, lastAction));
		
		remainingCommandString = "floating 8";

		assertEquals("deleting a task", TASK_DOES_NOT_EXIST_MESSAGE,
				CRUD.deleteTask(filename, remainingCommandString, lastAction));
		
		remainingCommandString = "26/10/2015 2";

		assertEquals("deleting a task", TASK_DOES_NOT_EXIST_MESSAGE,
				CRUD.deleteTask(filename, remainingCommandString, lastAction));
		
		remainingCommandString = "rec 6";

		assertEquals("deleting a task", TASK_DOES_NOT_EXIST_MESSAGE,
				CRUD.deleteTask(filename, remainingCommandString, lastAction));

		remainingCommandString = "floating 1";

		assertEquals("deleting a task", DELETED_MESSAGE,
				CRUD.deleteTask(filename, remainingCommandString, lastAction));

		// CRUD.addTask();

		remainingCommandString = "Go to school on weekdays;";

		assertEquals("adding a task", INVALID_INPUT_MESSAGE,
				CRUD.addTask(filename, remainingCommandString, lastAction));

		// 1100-1300 on 26/10/2015 (event task) exists
		
		// currently, if the task to be added is a (done or not done) event task, 
		// it is allowed to be added, if both its starting time and ending time is the same as
		// an existing (done or not done event task), i.e. multi-tasking
		// OR
		// the task to be added ends at or before the starting time of existing event tasks
		// OR
		// the task to be added starts at or after the ending time of existing event tasks
		
		remainingCommandString = "Meeting with CS2103/T group member(s); 1101-1300 on 26/10/2015; important;";

		assertEquals("adding a task", BLOCKED_MESSAGE,
				CRUD.addTask(filename, remainingCommandString, lastAction));
		
		remainingCommandString = "Meeting with CS2103/T group member(s); 1100-1259 on 26/10/2015; important;";

		assertEquals("adding a task", BLOCKED_MESSAGE,
				CRUD.addTask(filename, remainingCommandString, lastAction));	
		
		remainingCommandString = "Go to school on weekdays";

		assertEquals("adding a task", "The task " + "\"" + remainingCommandString + "\"" + " has been added." + "\n",
				CRUD.addTask(filename, remainingCommandString, lastAction));

		// CRUD.undo() - undoing something

		assertEquals("undoing something", ADD_UNDONE_MESSAGE, CRUD.undo(filename, lastAction));

		assertEquals("undoing something", DELETE_UNDONE_MESSAGE, CRUD.undo(filename, lastAction));
		
		// CRUD.markAsDone();
		
		remainingCommandString = "floating 1 not done";
		
		assertEquals("mark a task as not done, when it is already not done", INVALID_INPUT_MESSAGE, CRUD.markAsDone(filename, remainingCommandString, lastAction));
		
		remainingCommandString = "floating 1 done";
		
		assertEquals("mark a task as done, after it is done", MARKED_DONE_OR_NOT_DONE_MESSAGE, CRUD.markAsDone(filename, remainingCommandString, lastAction));
		
		remainingCommandString = "floating 1 done";
		
		assertEquals("mark a task as done, after it was already done", INVALID_INPUT_MESSAGE, CRUD.markAsDone(filename, remainingCommandString, lastAction));
		
		// CRUD.undo()
		
		assertEquals("undo the marking of a task as done", CHANGE_UNDONE_MESSAGE, CRUD.undo(filename, lastAction));

		// SortAndShow.readAndDisplayAll()

		assertEquals("show all tasks successfully i.e. reach the end of the method", ALL_TASKS_DISPLAYED_MESSAGE,
				SortAndShow.readAndDisplayAll(filename));

	}

}
```
###### src\ShowDays.java
``` java

import java.util.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.logging.*;

public class ShowDays {

	private static final Logger logger = Logger.getLogger(ShowDays.class.getName());

	private static final String STARTING_DATE_REQUEST_MESSAGE = "Please enter the starting date (format: dd/mm/yyyy): "
			+ "\n";

	private static final String TASKS_FOR_WEEK_DISPLAYED_FRONT_MESSAGE = "The tasks for the whole week starting on ";
	private static final String TASKS_FOR_WEEK_DISLAYED_BACK_MESSAGE = " are displayed.";

	private static final String DATE_GENERATED_MESSAGE = "The starting date provided by the user for displaying the specified week's tasks is valid. The next valid date generated is ";
	private static final String INVALID_INPUT_MESSAGE = "Invalid input. Please try again.";

	// number of days in each month for non-leap years
	private static final int JANUARY_DAYS = 31;
	private static final int FEBRUARY_DAYS = 28;
	private static final int MARCH_DAYS = 31;
	private static final int APRIL_DAYS = 30;
	private static final int MAY_DAYS = 31;
	private static final int JUNE_DAYS = 30;
	private static final int JULY_DAYS = 31;
	private static final int AUGUST_DAYS = 31;
	private static final int SEPTEMBER_DAYS = 30;
	private static final int OCTOBER_DAYS = 31;
	private static final int NOVEMBER_DAYS = 30;
	private static final int DECEMBER_DAYS = 31;

	// used to show tasks which are in 7 consecutive days
	// starting from the date the user indicates
	static void showWeek(String filename, String date) throws IOException {

		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {

				allTasksList.add(new Task(currentLine));
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		FlexWindow.getFeedback().appendText(STARTING_DATE_REQUEST_MESSAGE + "\n");
		FlexWindow.getFeedback().appendText("\n");

		logger.finest(STARTING_DATE_REQUEST_MESSAGE);
		System.out.println(STARTING_DATE_REQUEST_MESSAGE);
		System.out.println();

		// day 1

		String date1 = date.trim();

		// check if this input by the user is valid
		String tempDate = date1;

		if (!Checker.isValidDate(tempDate)) {

			assert (!Checker.isValidDate(tempDate));

			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();

			return;
		}

		assert (Checker.isValidDate(tempDate));

		date1.trim();

		SortAndShow.searchAndShowTask(filename, "date " + date1);

		// day 2
		String date2 = generateNextDate(date1);

		date2.trim();

		SortAndShow.searchAndShowTask(filename, "date " + date2);

		// day 3
		String date3 = generateNextDate(date2);

		date3.trim();

		SortAndShow.searchAndShowTask(filename, "date " + date3);

		// day 4

		String date4 = generateNextDate(date3);

		date4.trim();

		SortAndShow.searchAndShowTask(filename, "date " + date4);

		// day 5
		String date5 = generateNextDate(date4);

		date5.trim();

		SortAndShow.searchAndShowTask(filename, "date " + date5);

		// day 6
		String date6 = generateNextDate(date5);

		date6.trim();

		SortAndShow.searchAndShowTask(filename, "date " + date6);

		// day 7
		String date7 = generateNextDate(date6);

		date7.trim();

		SortAndShow.searchAndShowTask(filename, "date " + date7);

		logger.finest(TASKS_FOR_WEEK_DISPLAYED_FRONT_MESSAGE + date1 + TASKS_FOR_WEEK_DISLAYED_BACK_MESSAGE);
		System.out.println(TASKS_FOR_WEEK_DISPLAYED_FRONT_MESSAGE + date1 + TASKS_FOR_WEEK_DISLAYED_BACK_MESSAGE);
		System.out.println();
	}

	// generates the next date, given the day, month and year of a date
	// assumed to be in the format dd/mm/yyyy
	static String generateNextDate(String date) {

		assert (Checker.isValidDate(date));

		String tempDate = date;

		// the three variables of the current date
		int slashIndex1 = tempDate.indexOf("/");
		int currentDay = Integer.valueOf(tempDate.substring(0, slashIndex1));
		tempDate = tempDate.substring(slashIndex1 + 1).trim();

		int slashIndex2 = tempDate.indexOf("/");
		int currentMonth = Integer.valueOf(tempDate.substring(0, slashIndex2));

		int currentYear = Integer.valueOf(tempDate.substring(slashIndex2 + 1));

		// the three variables of the next date
		int newDay = -1;
		int newMonth = -1;
		int newYear = -1;

		boolean isLeapYear = false;
		boolean isLastDayOfMonth = false;
		boolean isLastDayOfYear = false;

		if (currentYear % 4 == 0) {
			isLeapYear = true;
		}

		if (currentMonth == 1) {
			if (currentDay == JANUARY_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 2) {
			// if it is a leap year, the last day of February is 29th of
			// February for that year
			// Note: FEBRUARY_DAYS = 28;
			if (isLeapYear) {
				if (currentDay == (FEBRUARY_DAYS + 1)) {
					isLastDayOfMonth = true;
				}
			} else {
				if (currentDay == (FEBRUARY_DAYS)) {
					isLastDayOfMonth = true;
				}
			}
		} else if (currentMonth == 3) {
			if (currentDay == MARCH_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 4) {
			if (currentDay == APRIL_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 5) {
			if (currentDay == MAY_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 6) {
			if (currentDay == JUNE_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 7) {
			if (currentDay == JULY_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 8) {
			if (currentDay == AUGUST_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 9) {
			if (currentDay == SEPTEMBER_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 10) {
			if (currentDay == OCTOBER_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 11) {
			if (currentDay == NOVEMBER_DAYS) {
				isLastDayOfMonth = true;
			}
		} else if (currentMonth == 12) {
			if (currentDay == DECEMBER_DAYS) {
				isLastDayOfMonth = true;
				isLastDayOfYear = true;
			}
		}

		// Case 1: if the date given is the last day of the year, that is
		// 31st December of that year
		if (isLastDayOfYear) {
			newDay = 1;
			newMonth = 1;
			newYear = currentYear + 1;
		}
		// Case 2: The given date is not the last day of the year,
		// but it is the last day of the month
		else if ((!isLastDayOfYear) && (isLastDayOfMonth)) {
			newDay = 1;
			newMonth = currentMonth + 1;
			newYear = currentYear;
		}
		// Case 3: The given date is not the last day of the year,
		// and also not the last day of the month
		else if ((!isLastDayOfYear) && (!isLastDayOfMonth)) {
			newDay = currentDay + 1;
			newMonth = currentMonth;
			newYear = currentYear;
		}

		logger.finest(DATE_GENERATED_MESSAGE + newDay + "/" + newMonth + "/" + newYear);

		return newDay + "/" + newMonth + "/" + newYear;

	}

}
```
###### src\SortAndShow.java
``` java

import java.util.*;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.logging.*;

public class SortAndShow {

	private static final Logger logger = Logger.getLogger(SortAndShow.class.getName());

	private static final String ALL_TASKS_DISPLAYED_MESSAGE = "All the tasks in the schedule are displayed.";
	private static final String INVALID_INPUT_MESSAGE = "Invalid input. Please try again.";
	// that is, it is valid only if its starting time, or ending time, are NOT
	// between the starting
	// and ending times of existing tasks which are NOT DONE YET

	private static final int HOUR_MINUTES = 60;

	// the form of searching for tasks without executing readAndExecuteCommand()
	// recursively
	// related to the user input command String "show week"
	static void searchAndShowTask(String filename, String remainingCommandString) throws IOException {

		ArrayList<Task> floatingTasksList = new ArrayList<Task>();
		ArrayList<Task> recurringTasksList = new ArrayList<Task>();
		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();

		int whitespaceIndex1 = remainingCommandString.indexOf(" ");

		if (whitespaceIndex1 < 0) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			System.out.println();
			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();

			return;
		}

		String searchVariableType = new String("");
		searchVariableType = remainingCommandString.substring(0, whitespaceIndex1).trim();

		String searchTerm = new String("");
		searchTerm = remainingCommandString.substring(whitespaceIndex1 + 1).trim();

		// reads in the file, line by line
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;
		ArrayList<Task> allTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {

				allTasksList.add(new Task(currentLine));
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		// CASE 1: searching for tasks using a matching string for the task name
		// floating, event, deadline and recurring tasks all have a task name
		if (searchVariableType.equalsIgnoreCase("task") || searchVariableType.equalsIgnoreCase("taskname")) {
			for (int i = 0; i < allTasksList.size(); i++) {
				// a floating task (done or not done), a deadline task (done or
				// not done) or an event task has a task
				// name (done or not done)

				// a deadline task or an event task, will have a taskname
				if (Checker.isEventTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isDoneEventTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getTaskName().indexOf(searchTerm) >= 0) {
						deadlineOrEventTasksList.add(allTasksList.get(i));
					}
				}

				// a floating task will also have a task name
				if (Checker.isFloatingTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isDoneFloatingTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getTaskName().indexOf(searchTerm) >= 0) {
						floatingTasksList.add(allTasksList.get(i));
					}
				}

				// a recurring task will also have a task name
				if (Checker.isRecurringTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getTaskName().indexOf(searchTerm) >= 0) {
						recurringTasksList.add(allTasksList.get(i));
					}
				}
			}
		} else if (searchVariableType.equalsIgnoreCase("date")) {

			// CASE 2: searching for tasks using an exact date
			// deadline tasks and event tasks have dates
			String tempDate = searchTerm;

			// check if the date used for searching, is valid
			if (!Checker.isValidDate(tempDate)) {

				assert (!Checker.isValidDate(tempDate));

				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return;
			}

			for (int i = 0; i < allTasksList.size(); i++) {
				// only a deadline task (done or not done) or an event task
				// (done or not done) will have a date
				if (Checker.isDeadlineTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isEventTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isDoneDeadlineTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isDoneEventTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getDate().equalsIgnoreCase(searchTerm)) {
						deadlineOrEventTasksList.add(allTasksList.get(i));
					}
				}
			}
		} else if (searchVariableType.equalsIgnoreCase("day")) {

			// CASE 3: searching for tasks using an exact day using an exact day
			// (name)
			// e.g. sunday
			// recurring tasks have days
			String tempDay = searchTerm;

			// check if the date used for searching, is valid
			if (!Checker.isValidDay(tempDay)) {

				assert (!Checker.isValidDay(tempDay));

				FlexWindow.getTextArea().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getTextArea().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return;
			}

			for (int i = 0; i < allTasksList.size(); i++) {
				// only a recurring task
				// will have a day e.g. monday
				if (Checker.isRecurringTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getDay().equalsIgnoreCase(searchTerm)) {
						recurringTasksList.add(allTasksList.get(i));
					}
				}
			}
		} else if (searchVariableType.equalsIgnoreCase("start")) {
			// CASE 4: searching for tasks using an exact starting time
			// event tasks and recurring tasks have starting times
			String tempStartTime = searchTerm;

			// check if the starting time used for searching, is valid
			if (!Checker.isValidTime(tempStartTime)) {

				assert (!Checker.isValidTime(tempStartTime));

				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return;
			}

			for (int i = 0; i < allTasksList.size(); i++) {
				// an event task will have a starting time
				if (Checker.isEventTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isDoneEventTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getStart().equalsIgnoreCase(searchTerm)) {
						deadlineOrEventTasksList.add(allTasksList.get(i));
					}
				}

				// a recurring task will also have a starting time
				if (Checker.isRecurringTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getStart().equalsIgnoreCase(searchTerm)) {
						recurringTasksList.add(allTasksList.get(i));
					}
				}
			}
		} else if (searchVariableType.equalsIgnoreCase("end")) {
			// CASE 5: searching for tasks using an exact ending time
			// deadline tasks, event tasks and recurring tasks have ending times
			String tempEndTime = searchTerm;

			if (!Checker.isValidTime(tempEndTime)) {

				assert (!Checker.isValidTime(tempEndTime));

				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();

				return;
			}

			for (int i = 0; i < allTasksList.size(); i++) {
				// deadline tasks and event tasks have an ending time
				if (Checker.isDeadlineTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isEventTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isDoneDeadlineTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isDoneEventTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getEnd().equalsIgnoreCase(searchTerm)) {
						deadlineOrEventTasksList.add(allTasksList.get(i));
					}
				}

				// recurring tasks also have an ending time
				if (Checker.isRecurringTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getEnd().equalsIgnoreCase(searchTerm)) {
						recurringTasksList.add(allTasksList.get(i));
					}
				}
			}
		} else if (searchVariableType.equalsIgnoreCase("priority")) {
			// CASE 6: search for tasks using a matching String in the priority
			// (level)
			// Only event tasks have a priority (level)

			for (int i = 0; i < allTasksList.size(); i++) {

				// event or deadline tasks have a priority (level)
				if (Checker.isEventTaskInput(allTasksList.get(i).getScheduleString())
						|| Checker.isDoneEventTaskInput(allTasksList.get(i).getScheduleString())) {
					if (allTasksList.get(i).getPriority().toLowerCase().indexOf(searchTerm.toLowerCase()) >= 0) {
						deadlineOrEventTasksList.add(allTasksList.get(i));
					}
				}

			}
		} else {
			// invalid input case
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();

			return;
		}

		String tempDate = new String("");

		if (!deadlineOrEventTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");
			tempDate = deadlineOrEventTasksList.get(0).getDate();
			FlexWindow.getTextArea().appendText("Date: " + tempDate + "\n");
			FlexWindow.getTextArea().appendText("\n");
		}

		int deadlineOrEventTasksListCount = 0;

		for (int j = 0; j < deadlineOrEventTasksList.size(); j++) {
			deadlineOrEventTasksListCount += 1;
			if (deadlineOrEventTasksList.get(j).getDate().equalsIgnoreCase(tempDate)) {
				FlexWindow.getTextArea().appendText(deadlineOrEventTasksListCount + ". "
						+ deadlineOrEventTasksList.get(j).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			} else {
				deadlineOrEventTasksListCount = 1;
				FlexWindow.getTextArea().appendText(
						"---------------------------------------------------------------------------------------------------------------------------"
								+ "\n");
				FlexWindow.getTextArea().appendText("\n");

				tempDate = deadlineOrEventTasksList.get(j).getDate();

				FlexWindow.getTextArea().appendText("Date: " + tempDate + "\n");
				FlexWindow.getTextArea().appendText("\n");

				FlexWindow.getTextArea().appendText(deadlineOrEventTasksListCount + ". "
						+ deadlineOrEventTasksList.get(j).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}
		}
		if (!floatingTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			// floating header "Floating"
			FlexWindow.getTextArea().appendText("Floating" + "\n");
			FlexWindow.getTextArea().appendText("\n");

			int floatingTasksListCount = 0;
			for (int k = 0; k < floatingTasksList.size(); k++) {
				floatingTasksListCount += 1;
				FlexWindow.getTextArea()
						.appendText(floatingTasksListCount + ". " + floatingTasksList.get(k).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}
		}

		if (!recurringTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			// recurring task header "Recurring"

			FlexWindow.getTextArea().appendText("Recurring" + "\n");
			FlexWindow.getTextArea().appendText("\n");

			int recurringTasksListCount = 0;

			for (int l = 0; l < recurringTasksList.size(); l++) {
				recurringTasksListCount += 1;
				FlexWindow.getTextArea().appendText(
						recurringTasksListCount + ". " + recurringTasksList.get(l).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}
		}

	}

	// displays all files in the schedule by Task.java's comparisonValue
	// in order of starting and ending time
	// each date, followed by each date's deadline tasks, then event tasks are
	// displayed
	// followed by floating tasks after each date
	static String readAndDisplayAll(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();
		ArrayList<Task> recurringTasksList = new ArrayList<Task>();
		ArrayList<Task> floatingTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isDeadlineTaskInput(currentLine) || Checker.isDoneDeadlineTaskInput(currentLine)
						|| Checker.isEventTaskInput(currentLine) || Checker.isDoneEventTaskInput(currentLine)) {
					deadlineOrEventTasksList.add(new Task(currentLine));
				} else if (Checker.isFloatingTaskInput(currentLine) || Checker.isDoneFloatingTaskInput(currentLine)) {
					floatingTasksList.add(new Task(currentLine));
				} else if (Checker.isRecurringTaskInput(currentLine)) {
					recurringTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		String tempDate = new String("");

		if (!deadlineOrEventTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");
			tempDate = deadlineOrEventTasksList.get(0).getDate();
			FlexWindow.getTextArea().appendText("Date: " + tempDate + "\n");
			FlexWindow.getTextArea().appendText("\n");
		}

		int deadlineOrEventTasksListCount = 0;

		for (int j = 0; j < deadlineOrEventTasksList.size(); j++) {
			deadlineOrEventTasksListCount += 1;
			if (deadlineOrEventTasksList.get(j).getDate().equalsIgnoreCase(tempDate)) {
				FlexWindow.getTextArea().appendText(deadlineOrEventTasksListCount + ". "
						+ deadlineOrEventTasksList.get(j).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			} else {
				deadlineOrEventTasksListCount = 1;
				FlexWindow.getTextArea().appendText(
						"---------------------------------------------------------------------------------------------------------------------------"
								+ "\n");
				FlexWindow.getTextArea().appendText("\n");

				tempDate = deadlineOrEventTasksList.get(j).getDate();

				FlexWindow.getTextArea().appendText("Date: " + tempDate + "\n");
				FlexWindow.getTextArea().appendText("\n");

				FlexWindow.getTextArea().appendText(deadlineOrEventTasksListCount + ". "
						+ deadlineOrEventTasksList.get(j).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}
		}
		if (!floatingTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			// floating header "Floating"

			FlexWindow.getTextArea().appendText("Floating" + "\n");
			FlexWindow.getTextArea().appendText("\n");

			int floatingTasksListCount = 0;
			for (int k = 0; k < floatingTasksList.size(); k++) {
				floatingTasksListCount += 1;
				FlexWindow.getTextArea()
						.appendText(floatingTasksListCount + ". " + floatingTasksList.get(k).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}

		}

		// recurring task header "Recurring"
		if (!recurringTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");

			FlexWindow.getTextArea().appendText("Recurring" + "\n");
			FlexWindow.getTextArea().appendText("\n");

			int recurringTasksListCount = 0;

			for (int l = 0; l < recurringTasksList.size(); l++) {
				recurringTasksListCount += 1;
				FlexWindow.getTextArea().appendText(
						recurringTasksListCount + ". " + recurringTasksList.get(l).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}
		}
		logger.finest(ALL_TASKS_DISPLAYED_MESSAGE);
		System.out.println(ALL_TASKS_DISPLAYED_MESSAGE);
		System.out.println();

		FlexWindow.getTextArea().appendText("\n");

		return ALL_TASKS_DISPLAYED_MESSAGE;
	}

	// used to display tasks given an ArrayList of Tasks
	static void readAndDisplayArrayListTasks(ArrayList<Task> taskList) {

		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();
		ArrayList<Task> recurringTasksList = new ArrayList<Task>();
		ArrayList<Task> floatingTasksList = new ArrayList<Task>();

		for (int i = 0; i < taskList.size(); i++) {
			if (Checker.isDeadlineTaskInput(taskList.get(i).getScheduleString())
					|| Checker.isDoneDeadlineTaskInput(taskList.get(i).getScheduleString())
					|| Checker.isEventTaskInput(taskList.get(i).getScheduleString())
					|| Checker.isDoneEventTaskInput(taskList.get(i).getScheduleString())) {
				deadlineOrEventTasksList.add(taskList.get(i));
			} else if (Checker.isFloatingTaskInput(taskList.get(i).getScheduleString())
					|| Checker.isDoneFloatingTaskInput(taskList.get(i).getScheduleString())) {
				floatingTasksList.add(taskList.get(i));
			} else if (Checker.isRecurringTaskInput(taskList.get(i).getScheduleString())) {
				recurringTasksList.add(taskList.get(i));
			}
		}

		String tempDate = new String("");

		if (!deadlineOrEventTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");
			tempDate = deadlineOrEventTasksList.get(0).getDate();
			FlexWindow.getTextArea().appendText("Date: " + tempDate + "\n");
			FlexWindow.getTextArea().appendText("\n");
		}

		int deadlineOrEventTasksListCount = 0;

		for (int j = 0; j < deadlineOrEventTasksList.size(); j++) {
			deadlineOrEventTasksListCount += 1;
			if (deadlineOrEventTasksList.get(j).getDate().equalsIgnoreCase(tempDate)) {
				FlexWindow.getTextArea().appendText(deadlineOrEventTasksListCount + ". "
						+ deadlineOrEventTasksList.get(j).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			} else {
				deadlineOrEventTasksListCount = 1;
				FlexWindow.getTextArea().appendText(
						"---------------------------------------------------------------------------------------------------------------------------"
								+ "\n");
				FlexWindow.getTextArea().appendText("\n");

				tempDate = deadlineOrEventTasksList.get(j).getDate();

				FlexWindow.getTextArea().appendText("Date: " + tempDate + "\n");
				FlexWindow.getTextArea().appendText("\n");

				FlexWindow.getTextArea().appendText(deadlineOrEventTasksListCount + ". "
						+ deadlineOrEventTasksList.get(j).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}
		}
		if (!floatingTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			// floating header "Floating"

			FlexWindow.getTextArea().appendText("Floating" + "\n");
			FlexWindow.getTextArea().appendText("\n");

			int floatingTasksListCount = 0;
			for (int k = 0; k < floatingTasksList.size(); k++) {
				floatingTasksListCount += 1;
				FlexWindow.getTextArea()
						.appendText(floatingTasksListCount + ". " + floatingTasksList.get(k).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}

		}

		// recurring task header "Recurring"
		if (!recurringTasksList.isEmpty()) {
			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");
			FlexWindow.getTextArea().appendText("\n");

			FlexWindow.getTextArea().appendText(
					"---------------------------------------------------------------------------------------------------------------------------"
							+ "\n");

			FlexWindow.getTextArea().appendText("Recurring" + "\n");
			FlexWindow.getTextArea().appendText("\n");

			int recurringTasksListCount = 0;

			for (int l = 0; l < recurringTasksList.size(); l++) {
				recurringTasksListCount += 1;
				FlexWindow.getTextArea().appendText(
						recurringTasksListCount + ". " + recurringTasksList.get(l).getDisplayString() + "\n");
				FlexWindow.getTextArea().appendText("\n");
			}
		}

		FlexWindow.getTextArea().appendText("\n");
	}

	// used to sort tasks by starting date and starting time
	static void sortAllTasksByDateAndStartingTime(ArrayList<Task> allTasksList) {

		ArrayList<Task> deadlineTasksList = new ArrayList<Task>();
		ArrayList<Task> eventTasksList = new ArrayList<Task>();

		ArrayList<Task> floatingTasksList = new ArrayList<Task>();
		ArrayList<Task> recurringTasksList = new ArrayList<Task>();

		for (int j = 0; j < allTasksList.size(); j++) {
			if (Checker.isDeadlineTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneDeadlineTaskInput(allTasksList.get(j).getScheduleString())) {
				deadlineTasksList.add(allTasksList.get(j));
			} else if (Checker.isEventTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneEventTaskInput(allTasksList.get(j).getScheduleString())) {
				eventTasksList.add(allTasksList.get(j));
			} else if (Checker.isFloatingTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneFloatingTaskInput(allTasksList.get(j).getScheduleString())) {
				floatingTasksList.add(allTasksList.get(j));
			} else if (Checker.isRecurringTaskInput(allTasksList.get(j).getScheduleString())) {
				recurringTasksList.add(allTasksList.get(j));
			}
		}

		// sort deadline tasks by ending time
		int size1 = deadlineTasksList.size();
		int a, start1, min_index1 = 0;

		for (start1 = 0; start1 < size1 - 1; start1++) {
			min_index1 = start1;

			for (a = start1 + 1; a < size1; a++) {
				if (deadlineTasksList.get(a).getDeadlineEndingTime() < deadlineTasksList.get(min_index1)
						.getDeadlineEndingTime()) {
					min_index1 = a;
				}
			}

			Task temp2 = deadlineTasksList.get(start1);
			Task temp3 = deadlineTasksList.get(min_index1);
			deadlineTasksList.set(start1, temp3);
			deadlineTasksList.set(min_index1, temp2);
		}

		// sort all deadline tasks by day

		int size100 = deadlineTasksList.size();
		int jj, start100, min_index100 = 0;

		for (start100 = 0; start100 < size100 - 1; start100++) {
			min_index100 = start100;

			for (jj = start100 + 1; jj < size100; jj++) {
				if (deadlineTasksList.get(jj).getActualDay() < deadlineTasksList.get(min_index100).getActualDay()) {
					min_index100 = jj;
				}
			}

			Task temp101 = deadlineTasksList.get(start100);
			Task temp102 = deadlineTasksList.get(min_index100);
			deadlineTasksList.set(start100, temp102);
			deadlineTasksList.set(min_index100, temp101);
		}

		// sort all deadline tasks by their month

		int size103 = deadlineTasksList.size();
		int kk, start103, min_index103 = 0;

		for (start103 = 0; start103 < size103 - 1; start103++) {
			min_index103 = start103;

			for (kk = start103 + 1; kk < size103; kk++) {
				if (deadlineTasksList.get(kk).getActualMonth() < deadlineTasksList.get(min_index103).getActualMonth()) {
					min_index103 = kk;
				}
			}

			Task temp104 = deadlineTasksList.get(start103);
			Task temp105 = deadlineTasksList.get(min_index103);
			deadlineTasksList.set(start103, temp105);
			deadlineTasksList.set(min_index103, temp104);
		}

		// sort all deadline tasks by their year

		int size106 = deadlineTasksList.size();
		int ll, start106, min_index106 = 0;

		for (start106 = 0; start106 < size106 - 1; start106++) {
			min_index106 = start106;

			for (ll = start106 + 1; ll < size106; ll++) {
				if (deadlineTasksList.get(ll).getActualYear() < deadlineTasksList.get(min_index106).getActualYear()) {
					min_index106 = ll;
				}
			}

			Task temp107 = deadlineTasksList.get(start106);
			Task temp108 = deadlineTasksList.get(min_index106);
			deadlineTasksList.set(start106, temp108);
			deadlineTasksList.set(min_index106, temp107);
		}

		// sort event tasks by starting time
		int size4 = eventTasksList.size();
		int b, start4, min_index4 = 0;

		for (start4 = 0; start4 < size4 - 1; start4++) {
			min_index4 = start4;

			for (b = start4 + 1; b < size4; b++) {
				if (eventTasksList.get(b).getEventStartingTime() < eventTasksList.get(min_index4)
						.getEventStartingTime()) {
					min_index4 = b;
				}
			}

			Task temp5 = eventTasksList.get(start4);
			Task temp6 = eventTasksList.get(min_index4);
			eventTasksList.set(start4, temp6);
			eventTasksList.set(min_index4, temp5);
		}

		// sort all event tasks by day

		int size109 = eventTasksList.size();
		int mm, start109, min_index109 = 0;

		for (start109 = 0; start109 < size109 - 1; start109++) {
			min_index109 = start109;

			for (mm = start109 + 1; mm < size109; mm++) {
				if (eventTasksList.get(mm).getActualDay() < eventTasksList.get(min_index109).getActualDay()) {
					min_index109 = mm;
				}
			}

			Task temp110 = eventTasksList.get(start109);
			Task temp111 = eventTasksList.get(min_index109);
			eventTasksList.set(start109, temp111);
			eventTasksList.set(min_index109, temp110);
		}

		// sort all event tasks by their month

		int size112 = eventTasksList.size();
		int nn, start112, min_index112 = 0;

		for (start112 = 0; start112 < size112 - 1; start112++) {
			min_index112 = start112;

			for (nn = start112 + 1; nn < size112; nn++) {
				if (eventTasksList.get(nn).getActualMonth() < eventTasksList.get(min_index112).getActualMonth()) {
					min_index112 = nn;
				}
			}

			Task temp113 = eventTasksList.get(start112);
			Task temp114 = eventTasksList.get(min_index112);
			eventTasksList.set(start112, temp114);
			eventTasksList.set(min_index112, temp113);
		}

		// sort all event tasks by their year

		int size115 = eventTasksList.size();
		int oo, start115, min_index115 = 0;

		for (start115 = 0; start115 < size115 - 1; start115++) {
			min_index115 = start115;

			for (oo = start115 + 1; oo < size115; oo++) {
				if (eventTasksList.get(oo).getActualYear() < eventTasksList.get(min_index115).getActualYear()) {
					min_index115 = oo;
				}
			}

			Task temp116 = eventTasksList.get(start115);
			Task temp117 = eventTasksList.get(min_index115);
			eventTasksList.set(start115, temp117);
			eventTasksList.set(min_index115, temp116);
		}

		ArrayList<Task> tempDeadlineOrEventTasksList = new ArrayList<Task>();

		// add the deadline tasks into deadlineOrEventTasksList
		for (int r = 0; r < deadlineTasksList.size(); r++) {
			tempDeadlineOrEventTasksList.add(deadlineTasksList.get(r));
		}

		// then, add the event tasks into deadlineOrEventTasksList
		for (int s = 0; s < eventTasksList.size(); s++) {
			tempDeadlineOrEventTasksList.add(eventTasksList.get(s));
		}

		// NOTE: Sorting by day, then month, then year, will keep the date(from
		// 1/1/1) in order

		// sort all deadline and event tasks by day

		int size10 = tempDeadlineOrEventTasksList.size();
		int d, start10, min_index10 = 0;

		for (start10 = 0; start10 < size10 - 1; start10++) {
			min_index10 = start10;

			for (d = start10 + 1; d < size10; d++) {
				if (tempDeadlineOrEventTasksList.get(d).getActualDay() < tempDeadlineOrEventTasksList.get(min_index10)
						.getActualDay()) {
					min_index10 = d;
				}
			}

			Task temp11 = tempDeadlineOrEventTasksList.get(start10);
			Task temp12 = tempDeadlineOrEventTasksList.get(min_index10);
			tempDeadlineOrEventTasksList.set(start10, temp12);
			tempDeadlineOrEventTasksList.set(min_index10, temp11);
		}

		// sort all deadline and event tasks by their month

		int size13 = tempDeadlineOrEventTasksList.size();
		int e, start13, min_index13 = 0;

		for (start13 = 0; start13 < size13 - 1; start13++) {
			min_index13 = start13;

			for (e = start13 + 1; e < size13; e++) {
				if (tempDeadlineOrEventTasksList.get(e).getActualMonth() < tempDeadlineOrEventTasksList.get(min_index13)
						.getActualMonth()) {
					min_index13 = e;
				}
			}

			Task temp14 = tempDeadlineOrEventTasksList.get(start13);
			Task temp15 = tempDeadlineOrEventTasksList.get(min_index13);
			tempDeadlineOrEventTasksList.set(start13, temp15);
			tempDeadlineOrEventTasksList.set(min_index13, temp14);
		}

		// sort all deadline and event tasks by their year

		int size16 = tempDeadlineOrEventTasksList.size();
		int f, start16, min_index16 = 0;

		for (start16 = 0; start16 < size16 - 1; start16++) {
			min_index16 = start16;

			for (f = start16 + 1; f < size16; f++) {
				if (tempDeadlineOrEventTasksList.get(f).getActualYear() < tempDeadlineOrEventTasksList.get(min_index16)
						.getActualYear()) {
					min_index16 = f;
				}
			}

			Task temp17 = tempDeadlineOrEventTasksList.get(start16);
			Task temp18 = tempDeadlineOrEventTasksList.get(min_index16);
			tempDeadlineOrEventTasksList.set(start16, temp18);
			tempDeadlineOrEventTasksList.set(min_index16, temp17);
		}

		// sort the deadline and event tasks for each YEAR
		// to make the date for each year in ORDER

		ArrayList<Task> dateSortedDeadlineOrEventTasksList = new ArrayList<Task>();

		if (!tempDeadlineOrEventTasksList.isEmpty()) {
			ArrayList<Task> subTaskListt = new ArrayList<Task>();

			int year = tempDeadlineOrEventTasksList.get(0).getActualYear();

			for (int tt = 0; tt < tempDeadlineOrEventTasksList.size(); tt++) {
				if (tempDeadlineOrEventTasksList.get(tt).getActualYear() == year) {
					subTaskListt.add(tempDeadlineOrEventTasksList.get(tt));
				} else {
					// sort subTaskList
					int size460 = subTaskListt.size();
					int aa, start460, min_index460 = 0;

					for (start460 = 0; start460 < size460 - 1; start460++) {
						min_index460 = start460;

						for (aa = start460 + 1; aa < size460; aa++) {
							if (subTaskListt.get(aa).getDayAndMonthValue() < subTaskListt.get(min_index460)
									.getDayAndMonthValue()) {
								min_index460 = aa;
							}
						}

						Task temp470 = subTaskListt.get(start460);
						Task temp480 = subTaskListt.get(min_index460);
						subTaskListt.set(start460, temp480);
						subTaskListt.set(min_index460, temp470);
					}

					for (int uu = 0; uu < subTaskListt.size(); uu++) {
						dateSortedDeadlineOrEventTasksList.add(subTaskListt.get(uu));
					}

					subTaskListt.clear();

					year = tempDeadlineOrEventTasksList.get(tt).getActualYear();

					subTaskListt.add(tempDeadlineOrEventTasksList.get(tt));

				}
			}

			if (!subTaskListt.isEmpty()) {
				int size490 = subTaskListt.size();
				int ddd, start490, min_index490 = 0;

				for (start490 = 0; start490 < size490 - 1; start490++) {
					min_index490 = start490;

					for (ddd = start490 + 1; ddd < size490; ddd++) {
						if (subTaskListt.get(ddd).getDayAndMonthValue() < subTaskListt.get(min_index490)
								.getDayAndMonthValue()) {
							min_index490 = ddd;
						}
					}

					Task temp500 = subTaskListt.get(start490);
					Task temp510 = subTaskListt.get(min_index490);
					subTaskListt.set(start490, temp510);
					subTaskListt.set(min_index490, temp500);
				}

				for (int bbb = 0; bbb < subTaskListt.size(); bbb++) {
					dateSortedDeadlineOrEventTasksList.add(subTaskListt.get(bbb));
				}

				subTaskListt.clear();
			}

		}

		// sort the deadline and event tasks for each date
		// such that for each date, deadline tasks (sorted by ending time)
		// are displayed first
		// followed by event tasks sorted by starting time
		// displayed after that,
		// PER DATE

		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();

		if (!dateSortedDeadlineOrEventTasksList.isEmpty()) {
			ArrayList<Task> subTaskList = new ArrayList<Task>();

			String date = dateSortedDeadlineOrEventTasksList.get(0).getDate();

			for (int t = 0; t < dateSortedDeadlineOrEventTasksList.size(); t++) {
				if (dateSortedDeadlineOrEventTasksList.get(t).getDate().equalsIgnoreCase(date)) {
					subTaskList.add(dateSortedDeadlineOrEventTasksList.get(t));
				} else {
					// sort subTaskList
					int size46 = subTaskList.size();
					int aa, start46, min_index46 = 0;

					for (start46 = 0; start46 < size46 - 1; start46++) {
						min_index46 = start46;

						for (aa = start46 + 1; aa < size46; aa++) {
							if (subTaskList.get(aa).getDeadlineOrEventTimeValue() < subTaskList.get(min_index46)
									.getDeadlineOrEventTimeValue()) {
								min_index46 = aa;
							}
						}

						Task temp47 = subTaskList.get(start46);
						Task temp48 = subTaskList.get(min_index46);
						subTaskList.set(start46, temp48);
						subTaskList.set(min_index46, temp47);
					}

					for (int u = 0; u < subTaskList.size(); u++) {
						deadlineOrEventTasksList.add(subTaskList.get(u));
					}

					subTaskList.clear();

					date = dateSortedDeadlineOrEventTasksList.get(t).getDate();

					subTaskList.add(dateSortedDeadlineOrEventTasksList.get(t));

				}
			}

			if (!subTaskList.isEmpty()) {
				int size49 = subTaskList.size();
				int dd, start49, min_index49 = 0;

				for (start49 = 0; start49 < size49 - 1; start49++) {
					min_index49 = start49;

					for (dd = start49 + 1; dd < size49; dd++) {
						if (subTaskList.get(dd).getDeadlineOrEventTimeValue() < subTaskList.get(min_index49)
								.getDeadlineOrEventTimeValue()) {
							min_index49 = dd;
						}
					}

					Task temp50 = subTaskList.get(start49);
					Task temp51 = subTaskList.get(min_index49);
					subTaskList.set(start49, temp51);
					subTaskList.set(min_index49, temp50);
				}

				for (int bb = 0; bb < subTaskList.size(); bb++) {
					deadlineOrEventTasksList.add(subTaskList.get(bb));
				}

				subTaskList.clear();
			}

		}

		// sort floating tasks in alphabetical order
		int size22 = floatingTasksList.size();
		int h, start22, min_index22 = 0;

		for (start22 = 0; start22 < size22 - 1; start22++) {
			min_index22 = start22;

			for (h = start22 + 1; h < size22; h++) {
				if (floatingTasksList.get(h).getTaskName()
						.compareToIgnoreCase(floatingTasksList.get(min_index22).getTaskName()) < 0) {
					min_index22 = h;
				}
			}

			Task temp23 = floatingTasksList.get(start22);
			Task temp24 = floatingTasksList.get(min_index22);
			floatingTasksList.set(start22, temp24);
			floatingTasksList.set(min_index22, temp23);
		}

		// sort recurring tasks by day and starting time
		int size28 = recurringTasksList.size();
		int m, start28, min_index28 = 0;

		for (start28 = 0; start28 < size28 - 1; start28++) {
			min_index28 = start28;

			for (m = start28 + 1; m < size28; m++) {
				if (recurringTasksList.get(m).getRecurringTaskValue() < recurringTasksList.get(min_index28)
						.getRecurringTaskValue()) {
					min_index28 = m;
				}
			}

			Task temp29 = recurringTasksList.get(start28);
			Task temp30 = recurringTasksList.get(min_index28);
			recurringTasksList.set(start28, temp30);
			recurringTasksList.set(min_index28, temp29);
		}

		ArrayList<Task> tempTasksList = new ArrayList<Task>();

		if (!deadlineOrEventTasksList.isEmpty()) {
			for (int n = 0; n < deadlineOrEventTasksList.size(); n++) {
				tempTasksList.add(deadlineOrEventTasksList.get(n));
			}
		}

		if (!floatingTasksList.isEmpty()) {
			for (int o = 0; o < floatingTasksList.size(); o++) {
				tempTasksList.add(floatingTasksList.get(o));
			}
		}

		if (!recurringTasksList.isEmpty()) {
			for (int p = 0; p < recurringTasksList.size(); p++) {
				tempTasksList.add(recurringTasksList.get(p));
			}
		}

		for (int z = 0; z < tempTasksList.size(); z++) {
			allTasksList.set(z, tempTasksList.get(z));
		}
	}

	// shows event tasks in the schedule
	static void showEventTasks(String filename) throws IOException {

		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> eventTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isEventTaskInput(currentLine) || Checker.isDoneEventTaskInput(currentLine)) {
					eventTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		SortAndShow.sortAllTasksByDateAndStartingTime(eventTasksList);

		SortAndShow.readAndDisplayArrayListTasks(eventTasksList);

	}

	// shows deadline tasks in the schedule
	static void showDeadlineTasks(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> deadlineTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isDeadlineTaskInput(currentLine) || Checker.isDoneDeadlineTaskInput(currentLine)) {
					deadlineTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		SortAndShow.sortAllTasksByDateAndStartingTime(deadlineTasksList);

		SortAndShow.readAndDisplayArrayListTasks(deadlineTasksList);

	}

	// shows recurring tasks in the schedule
	static void showRecurringTasks(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> recurringTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isRecurringTaskInput(currentLine)) {
					recurringTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		SortAndShow.sortAllTasksByDateAndStartingTime(recurringTasksList);

		readAndDisplayArrayListTasks(recurringTasksList);

	}

	// shows floating tasks in the schedule
	static void showFloatingTasks(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> floatingTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isFloatingTaskInput(currentLine) || Checker.isDoneFloatingTaskInput(currentLine)) {
					floatingTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		SortAndShow.sortAllTasksByDateAndStartingTime(floatingTasksList);

		SortAndShow.readAndDisplayArrayListTasks(floatingTasksList);

	}

	// show tasks which are marked as done by the user
	static void showDoneTasks(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> doneFloatingTasksList = new ArrayList<Task>();
		ArrayList<Task> doneDeadlineOrEventTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isDoneFloatingTaskInput(currentLine)) {
					doneFloatingTasksList.add(new Task(currentLine));
				} else if (Checker.isDoneDeadlineTaskInput(currentLine) || Checker.isDoneEventTaskInput(currentLine)) {
					doneDeadlineOrEventTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		for (int i = 0; i < doneDeadlineOrEventTasksList.size(); i++) {
			allTasksList.add(doneDeadlineOrEventTasksList.get(i));
		}

		for (int j = 0; j < doneFloatingTasksList.size(); j++) {
			allTasksList.add(doneFloatingTasksList.get(j));
		}

		SortAndShow.sortAllTasksByDateAndStartingTime(allTasksList);

		SortAndShow.readAndDisplayArrayListTasks(allTasksList);

	}

	// show tasks which are not marked as done by the user
	static void showNotDoneTasks(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> floatingTasksList = new ArrayList<Task>();
		ArrayList<Task> recurringTasksList = new ArrayList<Task>();
		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isFloatingTaskInput(currentLine)) {
					floatingTasksList.add(new Task(currentLine));
				} else if (Checker.isDeadlineTaskInput(currentLine) || Checker.isEventTaskInput(currentLine)) {
					deadlineOrEventTasksList.add(new Task(currentLine));
				} else if (Checker.isRecurringTaskInput(currentLine)) {
					recurringTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		for (int i = 0; i < deadlineOrEventTasksList.size(); i++) {
			allTasksList.add(deadlineOrEventTasksList.get(i));
		}

		for (int j = 0; j < floatingTasksList.size(); j++) {
			allTasksList.add(floatingTasksList.get(j));
		}

		for (int k = 0; k < recurringTasksList.size(); k++) {
			allTasksList.add(recurringTasksList.get(k));
		}

		SortAndShow.sortAllTasksByDateAndStartingTime(allTasksList);

		SortAndShow.readAndDisplayArrayListTasks(allTasksList);

	}

	// all tasks sorted by task name
	static void showByTaskName(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> floatingTasksList = new ArrayList<Task>();
		ArrayList<Task> recurringTasksList = new ArrayList<Task>();
		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isFloatingTaskInput(currentLine) || Checker.isDoneFloatingTaskInput(currentLine)) {
					floatingTasksList.add(new Task(currentLine));
				} else if (Checker.isDeadlineTaskInput(currentLine) || Checker.isDoneDeadlineTaskInput(currentLine)
						|| Checker.isEventTaskInput(currentLine) || Checker.isDoneEventTaskInput(currentLine)) {
					deadlineOrEventTasksList.add(new Task(currentLine));
				} else if (Checker.isRecurringTaskInput(currentLine) || Checker.isRecurringTaskInput(currentLine)) {
					recurringTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		// sort deadline tasks in alphabetical order
		int size11 = deadlineOrEventTasksList.size();
		int g, start11, min_index11 = 0;

		for (start11 = 0; start11 < size11 - 1; start11++) {
			min_index11 = start11;

			for (g = start11 + 1; g < size11; g++) {
				if (deadlineOrEventTasksList.get(g).getTaskName()
						.compareToIgnoreCase(deadlineOrEventTasksList.get(min_index11).getTaskName()) < 0) {
					min_index11 = g;
				}
			}

			Task temp12 = deadlineOrEventTasksList.get(start11);
			Task temp13 = deadlineOrEventTasksList.get(min_index11);
			deadlineOrEventTasksList.set(start11, temp13);
			deadlineOrEventTasksList.set(min_index11, temp12);
		}

		for (int i = 0; i < deadlineOrEventTasksList.size(); i++) {
			allTasksList.add(deadlineOrEventTasksList.get(i));
		}

		// sort floating tasks in alphabetical order
		int size22 = floatingTasksList.size();
		int h, start22, min_index22 = 0;

		for (start22 = 0; start22 < size22 - 1; start22++) {
			min_index22 = start22;

			for (h = start22 + 1; h < size22; h++) {
				if (floatingTasksList.get(h).getTaskName()
						.compareToIgnoreCase(floatingTasksList.get(min_index22).getTaskName()) < 0) {
					min_index22 = h;
				}
			}

			Task temp23 = floatingTasksList.get(start22);
			Task temp24 = floatingTasksList.get(min_index22);
			floatingTasksList.set(start22, temp24);
			floatingTasksList.set(min_index22, temp23);
		}

		for (int j = 0; j < floatingTasksList.size(); j++) {
			allTasksList.add(floatingTasksList.get(j));
		}

		// sort recurring tasks in alphabetical order
		int size33 = recurringTasksList.size();
		int j, start33, min_index33 = 0;

		for (start33 = 0; start33 < size33 - 1; start33++) {
			min_index33 = start33;

			for (j = start33 + 1; j < size33; j++) {
				if (recurringTasksList.get(j).getTaskName()
						.compareToIgnoreCase(recurringTasksList.get(min_index33).getTaskName()) < 0) {
					min_index33 = j;
				}
			}

			Task temp34 = recurringTasksList.get(start33);
			Task temp35 = recurringTasksList.get(min_index33);
			recurringTasksList.set(start33, temp35);
			recurringTasksList.set(min_index33, temp34);
		}

		for (int k = 0; k < recurringTasksList.size(); k++) {
			allTasksList.add(recurringTasksList.get(k));
		}

		SortAndShow.readAndDisplayArrayListTasks(allTasksList);
	}

	// show event, and recurring tasks by starting time
	static void showByTaskStartingTime(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> recurringTasksList = new ArrayList<Task>();
		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isEventTaskInput(currentLine) || Checker.isDoneEventTaskInput(currentLine)) {
					deadlineOrEventTasksList.add(new Task(currentLine));
				} else if (Checker.isRecurringTaskInput(currentLine) || Checker.isRecurringTaskInput(currentLine)) {
					recurringTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		// sort deadline tasks in alphabetical order
		int size11 = deadlineOrEventTasksList.size();
		int g, start11, min_index11 = 0;

		for (start11 = 0; start11 < size11 - 1; start11++) {
			min_index11 = start11;

			for (g = start11 + 1; g < size11; g++) {
				if (Integer.valueOf(deadlineOrEventTasksList.get(g).getStart().substring(0, 2)) * HOUR_MINUTES
						+ Integer.valueOf(deadlineOrEventTasksList.get(g).getStart().substring(2, 4)) < Integer.valueOf(
								deadlineOrEventTasksList.get(min_index11).getStart().substring(0, 2)) * HOUR_MINUTES
								+ Integer.valueOf(
										deadlineOrEventTasksList.get(min_index11).getStart().substring(2, 4))) {
					min_index11 = g;
				}
			}

			Task temp12 = deadlineOrEventTasksList.get(start11);
			Task temp13 = deadlineOrEventTasksList.get(min_index11);
			deadlineOrEventTasksList.set(start11, temp13);
			deadlineOrEventTasksList.set(min_index11, temp12);
		}

		for (int i = 0; i < deadlineOrEventTasksList.size(); i++) {
			allTasksList.add(deadlineOrEventTasksList.get(i));
		}

		// sort recurring tasks in alphabetical order
		int size33 = recurringTasksList.size();
		int j, start33, min_index33 = 0;

		for (start33 = 0; start33 < size33 - 1; start33++) {
			min_index33 = start33;

			for (j = start33 + 1; j < size33; j++) {
				if (Integer.valueOf(recurringTasksList.get(j).getStart().substring(0, 2)) * HOUR_MINUTES
						+ Integer.valueOf(recurringTasksList.get(j).getStart().substring(2, 4)) < Integer
								.valueOf(recurringTasksList.get(min_index33).getStart().substring(0, 2)) * HOUR_MINUTES
								+ Integer.valueOf(recurringTasksList.get(min_index33).getStart().substring(2, 4))) {
					min_index33 = j;
				}
			}

			Task temp34 = recurringTasksList.get(start33);
			Task temp35 = recurringTasksList.get(min_index33);
			recurringTasksList.set(start33, temp35);
			recurringTasksList.set(min_index33, temp34);
		}

		for (int k = 0; k < recurringTasksList.size(); k++) {
			allTasksList.add(recurringTasksList.get(k));
		}

		SortAndShow.readAndDisplayArrayListTasks(allTasksList);
	}

	// sorts deadline, event and recurring tasks by ending time
	static void showByTaskEndingTime(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> recurringTasksList = new ArrayList<Task>();
		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isDeadlineTaskInput(currentLine) || Checker.isDoneDeadlineTaskInput(currentLine)
						|| Checker.isEventTaskInput(currentLine) || Checker.isDoneEventTaskInput(currentLine)) {
					deadlineOrEventTasksList.add(new Task(currentLine));
				} else if (Checker.isRecurringTaskInput(currentLine) || Checker.isRecurringTaskInput(currentLine)) {
					recurringTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		// sort deadline tasks in alphabetical order
		int size11 = deadlineOrEventTasksList.size();
		int g, start11, min_index11 = 0;

		for (start11 = 0; start11 < size11 - 1; start11++) {
			min_index11 = start11;

			for (g = start11 + 1; g < size11; g++) {
				if (Integer.valueOf(deadlineOrEventTasksList.get(g).getEnd().substring(0, 2)) * HOUR_MINUTES
						+ Integer.valueOf(deadlineOrEventTasksList.get(g).getEnd().substring(2, 4)) < Integer.valueOf(
								deadlineOrEventTasksList.get(min_index11).getEnd().substring(0, 2)) * HOUR_MINUTES
								+ Integer.valueOf(deadlineOrEventTasksList.get(min_index11).getEnd().substring(2, 4))) {
					min_index11 = g;
				}
			}

			Task temp12 = deadlineOrEventTasksList.get(start11);
			Task temp13 = deadlineOrEventTasksList.get(min_index11);
			deadlineOrEventTasksList.set(start11, temp13);
			deadlineOrEventTasksList.set(min_index11, temp12);
		}

		for (int i = 0; i < deadlineOrEventTasksList.size(); i++) {
			allTasksList.add(deadlineOrEventTasksList.get(i));
		}

		// sort recurring tasks in alphabetical order
		int size33 = recurringTasksList.size();
		int j, start33, min_index33 = 0;

		for (start33 = 0; start33 < size33 - 1; start33++) {
			min_index33 = start33;

			for (j = start33 + 1; j < size33; j++) {
				if (Integer.valueOf(recurringTasksList.get(j).getEnd().substring(0, 2)) * HOUR_MINUTES
						+ Integer.valueOf(recurringTasksList.get(j).getEnd().substring(2, 4)) < Integer
								.valueOf(recurringTasksList.get(min_index33).getEnd().substring(0, 2)) * HOUR_MINUTES
								+ Integer.valueOf(recurringTasksList.get(min_index33).getEnd().substring(2, 4))) {
					min_index33 = j;
				}
			}

			Task temp34 = recurringTasksList.get(start33);
			Task temp35 = recurringTasksList.get(min_index33);
			recurringTasksList.set(start33, temp35);
			recurringTasksList.set(min_index33, temp34);
		}

		for (int k = 0; k < recurringTasksList.size(); k++) {
			allTasksList.add(recurringTasksList.get(k));
		}

		SortAndShow.readAndDisplayArrayListTasks(allTasksList);
	}

	// show event tasks by priority
	static void showByTaskPriority(String filename) throws IOException {
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> eventTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {
				if (Checker.isEventTaskInput(currentLine) || Checker.isDoneEventTaskInput(currentLine)) {
					eventTasksList.add(new Task(currentLine));
				}
			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		// sort deadline tasks in alphabetical order
		int size11 = eventTasksList.size();
		int g, start11, min_index11 = 0;

		for (start11 = 0; start11 < size11 - 1; start11++) {
			min_index11 = start11;

			for (g = start11 + 1; g < size11; g++) {
				if (eventTasksList.get(g).getPriority()
						.compareToIgnoreCase(eventTasksList.get(min_index11).getPriority()) < 0) {
					min_index11 = g;
				}
			}

			Task temp12 = eventTasksList.get(start11);
			Task temp13 = eventTasksList.get(min_index11);
			eventTasksList.set(start11, temp13);
			eventTasksList.set(min_index11, temp12);
		}

		for (int i = 0; i < eventTasksList.size(); i++) {
			allTasksList.add(eventTasksList.get(i));
		}

		SortAndShow.readAndDisplayArrayListTasks(allTasksList);
	}
}
```
###### src\TestDateFormat.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest1.java tests that valid dates in the required format are true, using valid date Strings, to test the 
// logic of checkDate()

public class TestDateFormat {

	@Test
	public void testOutput() throws IOException {

		assertTrue(Checker.isValidDate("31/12/2012"));

		// this is a case in the valid
		// date partition,
		// provided that it is a leap year.
		assertTrue(Checker.isValidDate("29/2/2012"));

		assertTrue(Checker.isValidDate("28/2/2012"));

		assertTrue(Checker.isValidDate("31/1/2012"));

		assertTrue(Checker.isValidDate("1/1/2012"));

		assertTrue(Checker.isValidDate("1/1/2011"));
		
		// the following are in the invalid partitions for a valid date
		assertTrue(!Checker.isValidDate("0/1/2012"));
		
		assertTrue(!Checker.isValidDate("1/-1/2012"));
		
		assertTrue(!Checker.isValidDate("32/1/2012"));
		
		assertTrue(!Checker.isValidDate("1/13/2012"));

	}
}
```
###### src\TestDeadlineDoneInput.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest5.java tests if the input for a deadline task works
// format of a deadline task

// input 
// add <taskname>; by <end> on <date>

// done
// <taskname>, by <end> on <date>

public class TestDeadlineDoneInput {

	@Test
	public void testOutput() throws IOException {

		// done deadline task (user input and/or file storage form)
		assertTrue(Checker.isDoneDeadlineTaskInput("task; by 2000 on 1/1/1 [done]"));

		assertTrue(!Checker.isDoneDeadlineTaskInput("task; by 2000 on 1/1/1[done]"));

		assertTrue(!Checker.isDoneDeadlineTaskInput("task; by 2000 on 1/1/1 [done]a"));

		assertTrue(!Checker.isDoneDeadlineTaskInput("t; by 2000 on 1/1/1 [done"));

		assertTrue(!Checker.isDoneDeadlineTaskInput("t, by 2000 on 1/1/1 [done"));

	}
}
```
###### src\TestDeadlineDoneOutput.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest5.java tests if the input for a deadline task works
// format of a deadline task

// output 
// <taskname>, by <end> on <date>

// done
// <taskname>, by <end> on <date>

public class TestDeadlineDoneOutput {

	@Test
	public void testOutput() throws IOException {

		// done deadline task output (GUI Display)

		assertTrue(Checker.isDoneDeadlineTaskOutput("task, by 2000 on 1/1/1 [done]"));

		assertTrue(!Checker.isDoneDeadlineTaskOutput("task, by 2000 on 1/1/1[done]"));

		assertTrue(!Checker.isDoneDeadlineTaskOutput("task, by 2000 on 1/1/1 [done]a"));

		assertTrue(!Checker.isDoneDeadlineTaskOutput("t, by 2000 on 1/1/1 [done"));

		assertTrue(!Checker.isDoneDeadlineTaskOutput("t, by 2000 on 1/1/1 [done"));

		// all Strings, without the "[done]" substring, are in
		// the invalid input partition for a deadline task which is done
		// (other than a null String)
		assertTrue(!Checker.isDoneDeadlineTaskOutput("t, by 2000 on 1/1/1 [done"));

	}
}
```
###### src\TestDeadlineInput.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest5.java tests if the input for a deadline task works
// format of a deadline task

// input 
// add <taskname>; by <end> on <date>

// done
// <taskname>, by <end> on <date>

public class TestDeadlineInput {

	@Test
	public void testOutput() throws IOException {

		// deadline task input
		assertTrue(Checker.isDeadlineTaskInput("task; by 2000 on 1/1/1"));

		assertTrue(!Checker.isDeadlineTaskInput("task; by 2000 on 1/1/1 [done]"));

		assertTrue(!Checker.isDeadlineTaskInput("task; by 2000 on 1/1/1 done]"));

		assertTrue(!Checker.isDeadlineTaskInput("task; by 2000 on 1/1/1 [done"));

		assertTrue(!Checker.isDeadlineTaskInput("task test testing, by 2359 On 12/12/2015"));

	}
}
```
