# A0131835J
###### src\ConfirmBox.java
``` java

import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.stage.Modality;
import javafx.stage.Stage;

public class ConfirmBox {

    static boolean answer;

    public static boolean confirm() {
        Stage window = new Stage();
        window.initModality(Modality.APPLICATION_MODAL);
        window.setTitle("Exit");
        window.setMinWidth(250);
        Label label = new Label();
        label.setText("Exit Flex?");

        Button yesButton = new Button();
        yesButton.setText("Yes");
        Button noButton = new Button();
        noButton.setText("No");

        yesButton.setOnAction(e -> {
            answer = true;
            window.close();
        });
        noButton.setOnAction(e -> {
            answer = false;
            window.close();
        });

        VBox layout1 = new VBox(10);
        HBox layout2 = new HBox(2);
        layout2.getChildren().addAll(yesButton, noButton);
        layout2.setAlignment(Pos.CENTER);
        layout1.getChildren().addAll(label, layout2);
        layout1.setAlignment(Pos.CENTER);
        Scene scene = new Scene(layout1);
        window.setScene(scene);
        window.showAndWait();

        return answer;
    }

}
```
###### src\CRUD.java
``` java
	static String markAsDone(String filename, String remainingCommandString, LastAction lastAction) throws IOException {
		String tempString = new String("");
		tempString = remainingCommandString.trim();

		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;
		ArrayList<Task> allTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {

				allTasksList.add(new Task(currentLine));
			}

		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		ArrayList<Task> deadlineOrEventTasksList = new ArrayList<Task>();
		ArrayList<Task> floatingTasksList = new ArrayList<Task>();

		for (int j = 0; j < allTasksList.size(); j++) {
			if (Checker.isDeadlineTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneDeadlineTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isEventTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneEventTaskInput(allTasksList.get(j).getScheduleString())) {
				deadlineOrEventTasksList.add(allTasksList.get(j));
			} else if (Checker.isFloatingTaskInput(allTasksList.get(j).getScheduleString())
					|| Checker.isDoneFloatingTaskInput(allTasksList.get(j).getScheduleString())) {
				floatingTasksList.add(allTasksList.get(j));
			}
		}

		int whitespaceIndex1 = tempString.indexOf(" ");
		if (whitespaceIndex1 < 0) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();
			return INVALID_INPUT_MESSAGE;
		}

		String firstTerm = tempString.substring(0, whitespaceIndex1).trim();

		tempString = tempString.substring(whitespaceIndex1 + 1).trim();

		if (tempString.length() == 0) {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();
			return INVALID_INPUT_MESSAGE;
		}

		if (Checker.isValidDate(firstTerm)) {
			// CASE 1: for a deadline task or an event task
			// mark <date> <number> done
			// mark <date> <number> not done

			assert (Checker.isValidDate(firstTerm));

			String date = firstTerm.trim();

			int whitespaceIndex2 = tempString.indexOf(" ");
			if (whitespaceIndex2 < 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			String number1 = tempString.substring(0, whitespaceIndex2).trim();
			char[] charArray1 = new char[number1.length()];
			number1.getChars(0, number1.length(), charArray1, 0);

			boolean isNumber4 = true;

			for (int c = 0; c < number1.length(); c++) {
				if (!Character.isDigit(charArray1[c])) {
					isNumber4 = false;
				}
			}

			if (!isNumber4) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			int taskCountForDate = 0;
			int firstTaskForDateIndex = -1;
			// e.g. firstTaskForDateIndex is 10
			// and taskCountForDate is 3 (index 10, index 11, index 12)
			// and the given number is 2
			// then the index of the task to have its information changed is
			// equal to 11
			// which is calculated as
			// firstTaskForDateIndex + Integer.valueOf(number1) - 1
			// = 10 + 2 - 1 = 11

			for (int i = 0; i < deadlineOrEventTasksList.size(); i++) {
				if (allTasksList.get(i).getDate().equalsIgnoreCase(date)) {
					firstTaskForDateIndex = i;
					break;
				}
			}

			for (int i = 0; i < deadlineOrEventTasksList.size(); i++) {
				if (allTasksList.get(i).getDate().equalsIgnoreCase(date)) {
					taskCountForDate += 1;
				}
			}

			if (firstTaskForDateIndex < 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			if ((Integer.valueOf(number1) <= 0) || (Integer.valueOf(number1) > taskCountForDate)) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			tempString = tempString.substring(whitespaceIndex2 + 1).trim();

			if (tempString.length() == 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			int notWhitespaceDoneIndex2 = tempString.indexOf("not done");
			int doneIndex2 = tempString.indexOf("done");

			if (notWhitespaceDoneIndex2 == 0) {
				tempString = tempString.substring(notWhitespaceDoneIndex2 + 8).trim();

				if (tempString.length() != 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getDone() == null) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1)
						.getScheduleString();

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setNotDone();

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(
						allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getScheduleString()));

			} else if (doneIndex2 == 0) {
				tempString = tempString.substring(doneIndex2 + 4).trim();

				if (tempString.length() != 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getDone() != null) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1)
						.getScheduleString();

				allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).setDone();

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(
						allTasksList.get(firstTaskForDateIndex + Integer.valueOf(number1) - 1).getScheduleString()));

			}

		} else if (firstTerm.equalsIgnoreCase("floating")) {
			// For editing a floating task
			// mark floating <number> done
			// mark floating <number> not done

			int whitespaceIndex3 = tempString.indexOf(" ");
			if (whitespaceIndex3 < 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			String number2 = tempString.substring(0, whitespaceIndex3).trim();
			char[] charArray1 = new char[number2.length()];
			number2.getChars(0, number2.length(), charArray1, 0);

			boolean isNumber2 = true;

			for (int c = 0; c < number2.length(); c++) {
				if (!Character.isDigit(charArray1[c])) {
					isNumber2 = false;
				}
			}

			if (!isNumber2) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			if ((Integer.valueOf(number2) <= 0) || (Integer.valueOf(number2) > floatingTasksList.size())) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			tempString = tempString.substring(whitespaceIndex3 + 1).trim();

			if (tempString.length() == 0) {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}

			int notWhitespaceDoneIndex2 = tempString.indexOf("not done");
			int doneIndex2 = tempString.indexOf("done");

			if (notWhitespaceDoneIndex2 == 0) {
				tempString = tempString.substring(notWhitespaceDoneIndex2 + 8).trim();

				if (tempString.length() != 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (allTasksList.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1)
						.getDone() == null) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList
						.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1).getScheduleString();

				allTasksList.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1).setNotDone();

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(allTasksList
						.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1).getScheduleString()));

			} else if (doneIndex2 == 0) {
				tempString = tempString.substring(doneIndex2 + 4).trim();

				if (tempString.length() != 0) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				if (allTasksList.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1)
						.getDone() != null) {
					FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
					FlexWindow.getFeedback().appendText("\n");

					logger.finest(INVALID_INPUT_MESSAGE);
					System.out.println(INVALID_INPUT_MESSAGE);
					System.out.println();
					return INVALID_INPUT_MESSAGE;
				}

				String taskBeforeChange = allTasksList
						.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1).getScheduleString();

				allTasksList.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1).setDone();

				lastAction.setPreviousAction("change");
				lastAction.setPreviousChangedScheduleString(taskBeforeChange);
				lastAction.setPreviousTask(new Task(allTasksList
						.get(deadlineOrEventTasksList.size() + Integer.valueOf(number2) - 1).getScheduleString()));
			} else {
				FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				FlexWindow.getFeedback().appendText("\n");

				logger.finest(INVALID_INPUT_MESSAGE);
				System.out.println(INVALID_INPUT_MESSAGE);
				System.out.println();
				return INVALID_INPUT_MESSAGE;
			}
		} else {
			FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			FlexWindow.getFeedback().appendText("\n");

			logger.finest(INVALID_INPUT_MESSAGE);
			System.out.println(INVALID_INPUT_MESSAGE);
			System.out.println();
			return INVALID_INPUT_MESSAGE;
		}

		// sort all tasks by date and starting time
		SortAndShow.sortAllTasksByDateAndStartingTime(allTasksList);

		// overwrites to the file, line by line
		BufferedWriter writer = new BufferedWriter(new FileWriter(filename));

		for (int i = 0; i < allTasksList.size(); i++) {
			writer.write(allTasksList.get(i).getScheduleString());
			writer.newLine();
		}

		writer.close();

		FlexWindow.getFeedback().appendText(MARKED_DONE_OR_NOT_DONE_MESSAGE + "\n");
		FlexWindow.getFeedback().appendText("\n");

		logger.finest(MARKED_DONE_OR_NOT_DONE_MESSAGE);
		System.out.println(MARKED_DONE_OR_NOT_DONE_MESSAGE);
		System.out.println();

		return MARKED_DONE_OR_NOT_DONE_MESSAGE;

	}

	// reads the .txt file, then clears it
	static void clear(String filename, LastAction lastAction) throws IOException {
		// reads in the file, line by line
		BufferedReader reader = null;

		reader = new BufferedReader(new FileReader(filename));
		String currentLine = null;

		ArrayList<Task> allTasksList = new ArrayList<Task>();

		do {
			currentLine = reader.readLine();
			if (currentLine != null) {

				allTasksList.add(new Task(currentLine));

			}
		} while (currentLine != null);

		if (reader != null) {
			reader.close();
		}

		lastAction.setClearTaskList(allTasksList);
		lastAction.setPreviousAction("clear");

		// overwrite the .txt file with one single empty String
		BufferedWriter writer = new BufferedWriter(new FileWriter(filename));
		writer.write("");

		writer.close();

		logger.finest(CLEAR_MESSAGE);
		System.out.println(CLEAR_MESSAGE);
		System.out.println();

		FlexWindow.getFeedback().appendText(CLEAR_MESSAGE);
		FlexWindow.getFeedback().appendText("\n");

	}
}
```
###### src\FindFilename.java
``` java

import java.io.File;
import java.io.IOException;

public class FindFilename {
	private static String filename;
	private static final String FILENAME_ACCEPTED_MESSAGE = "The filename is accepted.";
	private static final String PROCEED_MESSAGE = "Please proceed with the user input commands.";
	private static final String FILENAME_INPUT_MESSAGE = "Please enter the full path name of the .txt schedule file, including its name. For example: C:"
			+ "\\" + "Users" + "\\" + "Owner" + "\\" + "Documents" + "\n" + "\\" + "Flex" + "." + "java" + "\\" + "src" + "\\"
			+ "FlexTest" + "." + "txt";
	private static final String INVALID_INPUT_MESSAGE = "Invalid input. Please try again.";

	
	public static boolean find(String input) throws IOException{

		filename = input;
		filename.trim();


		File tempFile = new File(filename);

		if ((!tempFile.exists()) || (filename.length() <= 4)
				|| (!filename.substring(filename.length() - 4, filename.length()).equalsIgnoreCase(".txt"))) {

			FlexWindow.getTextArea().appendText(INVALID_INPUT_MESSAGE + "\n" +
			FILENAME_INPUT_MESSAGE + "\n");
			FlexWindow.getTextArea().appendText("\n");

			System.out.println(INVALID_INPUT_MESSAGE + FILENAME_INPUT_MESSAGE);
			System.out.println();
			
			return false;
		}

		System.out.println();
		System.out.println(FILENAME_ACCEPTED_MESSAGE + PROCEED_MESSAGE);
		System.out.println();

		FlexWindow.getFeedback().appendText(FILENAME_ACCEPTED_MESSAGE + "\n" + 
				PROCEED_MESSAGE + "\n");
		FlexWindow.getTextArea().appendText("\n");
		
		SortAndShow.readAndDisplayAll(input);

		return true;

	}
	
	public static String getFilename(){
		return filename;
	}
}
```
###### src\Flex.java
``` java
// Flex.java
// Uses Task objects from Task.java
// Able to
// 1. Add a task - clashes with existing tasks, on the same date, which have not been marked as done
// are prevented from being added (invalid case)
// 2. Delete a task - tasks which do not exist, cannot be deleted (invalid case)
// 3. Edit a Task's variable (attribute), EXCEPT for its comparisonValue 
// 4. Automatically sort tasks by date and starting time after valid input for points 1. , 2. , and 3.
// 5. Show tasks by "numerical" priorityLevel (where "1" is the highest), but not alter the schedule file
// This method works only if the user has chosen to use positive integers as priority levels
// i.e. The user can choose to use alphabets instead, for the priority levels, for 1. and 2.
// 6. Search for tasks by one of the variables(attributes) for tasks, EXCEPT by the tasks' "comparisonValue" s
// 7. Undo the very last VALID action done for 1. , 2. and 3. - searching and showing(displaying) commands will not have their last VALID action saved 
// 8. Able to show tasks which has priority levels not being numbers (not all characters in the priority level string are numerical digits)

import java.io.IOException;

import java.util.logging.*;

public class Flex {

	private static final Logger logger = Logger.getLogger(Flex.class.getName());

	private static String command;
	private static LastAction lastAction = new LastAction();

	private static final String DONE_TASKS_DISPLAYED_MESSAGE = "The tasks in the schedule, which are marked as "
			+ "done" + " for their categories, are displayed.";
	private static final String NOT_DONE_TASKS_DISPLAYED_MESSAGE = "The tasks in the schedule, which are not marked as "
			+ "done" + " for their categories, are displayed.";
	private static final String DEADLINE_TASKS_DISPLAYED_MESSAGE = "Deadline tasks in the schedule are displayed.";
	private static final String FLOATING_TASKS_DISPLAYED_MESSAGE = "Floating tasks in the schedule are displayed.";
	private static final String EVENT_TASKS_DISPLAYED_MESSAGE = "Event tasks in the schedule are displayed.";
	private static final String RECURRING_TASKS_DISPLAYED_MESSAGE = "Recurring tasks in the schedule are displayed.";

	private static final String INVALID_INPUT_MESSAGE = "Invalid command. Please try again.";

	private static final String EXIT_MESSAGE = "Exiting the program.";

	// Note: The programs starts by typing "java Flex" in command line prompt.

	public static void processCommand(String input, String filename) {
		command = input;

		try {
			readAndExecuteCommand(filename, lastAction);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

```
###### src\FlexHelpSheet.txt
``` txt
---------------------------------------------------------------

Deadline task:

1) Add a deadline task:
add <taskname>; by <end> on <date>

2) Add a done deadline task:
add <taskname>; by <end> on <date> [done]

3) Delete a deadline task:
delete <date> number>

4) Mark deadline task as done:
mark <date> <number> done

5) Mark deadline task as not done:
mark <date> <number> not done

6) Change the taskname of a deadline task:
change <date> <number> taskname to <newtaskname>

7) Change the date of a deadline task:
change <date> <number> date to <newdate>

8) Change the ending time of the deadline task:
change <date> <number> end by <new end>

9) Change the ending time and date of the deadline task:
change <date> <number> by <newend> on <newdate>

---------------------------------------------------------------

Event task:

1) Add an event task:
add <taskname>; <start>-<end> on <date>; <priority>

2) Add a done event task:
add <taskname>; <start>-<end> on <date>; <priority> [done]

3) Delete an event task:
delete <date> number

4) Mark an event task as done:
mark <date> <number> done

5) Mark an event task as not done:
mark <date> <number> not done

6) Change the taskname of an event task:
change <date> <number> taskname to <newtaskname>

7) Change the date of an event task:
change <date> <number> date to <newdate>

8) Change the priority of an event task:
change <date> <number> priority to <newpriority>

9) Change the start and end times of an event task
change <date> <number> time to <newstart>-<newend> 

---------------------------------------------------------------

Floating tasks:

1) Add a floating task:
add <taskname>

2) Delete a floating task:
delete floating <nunber>

3) Add a done floating task:
add <taskname> [done]

4) Mark a floating task as done:
mark floating <number> done

5) Mark a floating task as not done:
mark floating <number> not done

6) Change the taskname of a floating task
change floating <number> taskname to <newtaskname>

---------------------------------------------------------------

Recurring tasks:

1) Add a recurring task
add <taskname>; <start>-<end> every <day>;

2) Delete a recurring task
delete rec <number>

3) Change the taskname of a recurring task:
change rec <number> taskname to <newtaskname>

4) Change the day of a recurring task:
change rec <number> to every <newday> 

5) Change the start and end times of a recurring task:
change rec <number> time to <newstart>-<newend>

---------------------------------------------------------------

Search functions:


1) Search for a task using a matching string in the taskname: 
search taskname <tasknamematchingstring>

2) Search for a task using an exact date: 
search date <exactdate>

3) Search for a task using an exact day:
search day <exactday>

4) Search for a task using an exact start time:
search start <exactstartingtime>
      
5) Search for a task using an exact ending time:
search end <exactendingtime>

6) Search for a task using a matching string in the task priority:
search priority <prioritymatchingstring>

---------------------------------------------------------------

Show functions:

1) Show all tasks: 
show all

2) Show all done tasks:
show done

3) Show all tasks which are not done: 
show not done

4) Show all deadline tasks: 
show deadline

5) Show all event tasks:
show event

6) Show all recurring tasks: 
show recurring

7) Show all floating tasks: 
show floating

8) Show all tasks by taskname: 
show by taskname

9) Show all deadline and event tasks by date: 
show by date

10) Show all recurring tasks by day: 
show by day

11) Show all event tasks by start time: 
show by start

12) Show all deadline and event tasks by end time: 
show by end

13) Show all event tasks by priority: 
show by priority

14) show the tasks for a given week (of seven days), given the starting(first) date of that week:
show week <exactstartingdate>
-----------------------------------------------------
```
###### src\FlexWindow.java
``` java

import java.io.IOException;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.geometry.Rectangle2D;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.GridPane;
import javafx.stage.Screen;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;

public class FlexWindow extends Application {
	//To take note of commands from the user
	private static TextField input;
	//To display the list of tasks
	private static TextArea textArea;
	//To display the feedback to users
	private static TextArea feedback;
	private static double width;
	private static double height;
	private static Stage window;
	private static boolean haveFilename;
	private static final String FILENAME_INPUT_MESSAGE = "Welcome to Flex! Please enter the full path name of the .txt schedule file. E.g.: C:"
			+ "\\" + "Users" + "\\" + "Owner" + "\\" + "Documents" + "\n" + "\\" + "Flex" + "." + "java" + "\\" + "src" + "\\"
			+ "FlexTest" + "." + "txt";
	
	public static void main(String[] args) {
		launch(args);
	}
	
	@Override
	public void start(Stage primaryStage){
		window = primaryStage;
		window.setTitle("Flex");
		getScreenSize();
		
		//Initialize variables
		input = new TextField();
		GridPane.setConstraints(input, 0, 3);
		
		textArea = new TextArea(FILENAME_INPUT_MESSAGE);
		GridPane.setConstraints(textArea, 0, 1);
		
		feedback = new TextArea();
		GridPane.setConstraints(feedback, 0, 2);
		
		Button help = new Button("Help");
		GridPane.setConstraints(help, 0, 0);
		
		haveFilename = false;
		
		//Set GridPane
		GridPane grid = new GridPane();
        grid.setAlignment(Pos.CENTER);
        grid.setHgap(10);
        grid.setVgap(8);
        grid.setPadding(new Insets(10, 10, 10, 10));
        grid.getChildren().addAll(help, textArea, feedback, input);
 
        //Set textArea
        textArea.setPrefColumnCount(40);
        textArea.setPrefRowCount(20);
        setTextAreaSize();
        setEditability();

		input.setPromptText("command");

		help.setOnAction(new EventHandler<ActionEvent>(){

			@Override
			public void handle(ActionEvent event) {
				HelpSheet.showHelpSheet();
			}
			
		});

        Scene scene = new Scene(grid, width/2, height/1.5);
		//Action when enter is pressed
		scene.setOnKeyPressed(new EventHandler<KeyEvent>(){

			@Override
			public void handle(KeyEvent event) {
				if(event.getCode().equals(KeyCode.ENTER)){
					String command = input.getText().trim();
					if(haveFilename){
						feedback.setText("");
						textArea.setText("");
						String filename = FindFilename.getFilename();
						Flex.processCommand(command, filename);
					}else{
						feedback.setText("");
						textArea.setText("");
						try {
							haveFilename = FindFilename.find(command);
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
					input.setText("");
				}
			}
			
		});
		
		//Request for closing
		window.setOnCloseRequest(new EventHandler<WindowEvent>(){

			@Override
			public void handle(WindowEvent event) {
				event.consume();
				closeProgram();
			}
			
		});
        
		window.setScene(scene);
		window.show();
	}
	
	public void setEditability(){
		textArea.setEditable(false);
		feedback.setEditable(false);
	}
	
	public static TextArea getFeedback(){
		return feedback;
	}
	
	public static TextArea getTextArea(){
		return textArea;
	}
	
	private static void closeProgram(){
		boolean result = ConfirmBox.confirm();
		if(result)
			window.close();
	}
	
	// set the size of textAreas and textField
	public void setTextAreaSize(){
		textArea.setPrefHeight((height-50) *7 /9);
		textArea.setMaxHeight(height *7 /9);
		input.setPrefWidth(width);
		feedback.setPrefHeight((height-50) /9);
		feedback.setMaxHeight(height /9);
	}
	
	//Get the size of the screen and set place of the window in the screen
	private void getScreenSize(){
	    Screen screen = Screen.getPrimary();
	    Rectangle2D bounds = screen.getVisualBounds();
	    width = bounds.getWidth();
	    height = bounds.getHeight()-50;
	    window.setX(width/4);
	    window.setY(height/6);
	}
	
	public static double getHeight(){
		return height;
	}
	
	public static double getWidth(){
		return width;
	}
}
```
###### src\HelpSheet.java
``` java

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Scene;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.PropertyValueFactory;
import javafx.scene.layout.GridPane;
import javafx.stage.Stage;

public class HelpSheet {

	@SuppressWarnings("unchecked")
	public static void showHelpSheet() {
		Stage window = new Stage();
		
		double height = FlexWindow.getHeight();
		double width = FlexWindow.getWidth();
		window.setTitle("Help Sheet");
		window.setHeight(height*3/5);
		window.setWidth(width*3/5);

		// Function column for Deadline
		TableColumn<Method, Double> functionColumn = new TableColumn<>("Function");
		functionColumn.setMinWidth(width*4/15);
		functionColumn.setCellValueFactory(new PropertyValueFactory<>("function"));

		// howToUse column for Deadline
		TableColumn<Method, String> howToUseColumn = new TableColumn<>("How To Use");
		howToUseColumn.setMinWidth(width*4/15);
		howToUseColumn.setCellValueFactory(new PropertyValueFactory<>("howToUse"));

		// set up the table
		TableView<Method> table = new TableView<>();
		table.setItems(getMethod());
		table.getColumns().addAll(functionColumn, howToUseColumn);
		table.setPrefHeight(height*11/20);
		GridPane.setConstraints(table, 0, 0);

		GridPane grid = new GridPane();
		grid.setAlignment(Pos.CENTER);
		grid.setHgap(10);
		grid.setVgap(8);
		grid.setPadding(new Insets(10, 10, 10, 10));
		grid.getChildren().addAll(table);
		Scene scene = new Scene(grid, width, height);

		window.setScene(scene);
		window.show();
	}

	public static ObservableList<Method> getMethod() {
		ObservableList<Method> methods = FXCollections.observableArrayList();

		methods.add(new Method("", ""));

		// Undo
		methods.add(new Method("To undo the last action/command input:", "undo"));

		methods.add(new Method("", ""));

		// Clear function
		methods.add(new Method("To clear entire .txt storage file:", "clear"));

		methods.add(new Method("", ""));

		// Deadline task
		methods.add(new Method("Deadlines tasks commands:", ""));
		methods.add(new Method("Add a deadline task", "add <taskname>; by <end> on <date>"));
		methods.add(new Method("Delete a deadline task", "delete <date> <index>"));
		methods.add(new Method("Mark deadline task as done", "mark <date> <index> done"));
		methods.add(new Method("Mark deadline task as not done", "mark <date> <index> not done"));
		methods.add(new Method("Change the taskname of a deadline task",
				"change <date> <index> taskname to <newtaskname>"));
		methods.add(new Method("Change the date of a deadline task", "change <date> <index> date to <newdate>"));
		methods.add(
				new Method("Change the ending time of the deadline task", "change <date> <index> end by <new end>"));
		methods.add(new Method("Change the ending time and date of the deadline task",
				"change <date> <index> by <newend> on <newdate>"));

		methods.add(new Method("", ""));

		// Event task
		methods.add(new Method("Event tasks commands:", ""));
		methods.add(new Method("Add an event task", "add <taskname>; <start>-<end> on <date>; <priority>"));
		methods.add(new Method("Delete an event task", "delete <date> <index>"));
		methods.add(new Method("Mark an event task as done", "mark <date> <index> done"));
		methods.add(new Method("Mark an event task as not done", "mark <date> <index> not done"));
		methods.add(
				new Method("Change the taskname of an event task", "change <date> <index> taskname to <newtaskname>"));
		methods.add(new Method("Change the date of an event task", "change <date> <index> date to <newdate>"));
		methods.add(
				new Method("Change the priority of an event task", "change <date> <index> priority to <newpriority>"));
		methods.add(new Method("Change the start and end times of an event task",
				"change <date> <index> time to <newstart>-<newend>"));

		methods.add(new Method("", ""));

		// Floating task
		methods.add(new Method("Floating tasks commands:", ""));
		methods.add(new Method("Add a floating task", "add <taskname>"));
		methods.add(new Method("Delete a floating task", "delete floating <index>"));
		methods.add(new Method("Mark a floating task as done", "mark floating <index> done"));
		methods.add(new Method("Mark a floating task as not done", "mark floating <index> not done"));
		methods.add(new Method("Change the taskname of a floating task",
				"change floating <index> taskname to <newtaskname>"));

		methods.add(new Method("", ""));

		// Recurring task
		methods.add(new Method("Recurring tasks commands:", ""));
		methods.add(new Method("Add a recurring task", "add <taskname>; <start>-<end> every <day>"));
		methods.add(new Method("Delete a recurring task", "delete rec <number>"));
		methods.add(new Method("Change the taskname of a recurring task", "change rec <index> taskname to <newtaskname>"));
		methods.add(new Method("Change the day of a recurring task", "change rec <index> to every <newday>"));
		methods.add(new Method("Change the start and end times of a recurring task",
				"change rec <index> time to <newstart>-<newend>"));

		methods.add(new Method("", ""));

		// Search functions
		methods.add(new Method("Search commands:", ""));
		methods.add(new Method("Search for a task using a keyword in the taskname",
				"search taskname <keyword>"));
		methods.add(new Method("Search for a task using an exact date", "search date <exactdate>"));
		methods.add(new Method("Search for a task using an exact day", "search day <exactday>"));
		methods.add(new Method("Search for a task using an exact start time", "search start <exactstartingtime>"));
		methods.add(new Method("Search for a task using an exact ending time", "search end <exactendingtime>"));
		methods.add(new Method("Search for a task by priority", "search priority <priority>"));

		methods.add(new Method("", ""));

		// Show functions
		methods.add(new Method("Show commands:", ""));
		methods.add(new Method("Show all tasks", "show all"));
		methods.add(new Method("Show all done tasks", "show done"));
		methods.add(new Method("Show all tasks which are not done", "show not done"));
		methods.add(new Method("Show all deadline tasks", "show deadline"));
		methods.add(new Method("Show all event tasks", "show event"));
		methods.add(new Method("Show all recurring tasks", "show recurring"));
		methods.add(new Method("Show all floating tasks", "show floating"));
		methods.add(new Method("Show all tasks by taskname", "show by taskname"));
		methods.add(new Method("Show all deadline and event tasks by date", "show by date"));
		methods.add(new Method("Show all recurring tasks by day", "show by day"));
		methods.add(new Method("Show all event tasks by start time", "show by start"));
		methods.add(new Method("Show all deadline and event tasks by end time", "show by end"));
		methods.add(new Method("Show all event tasks by priority", "show by priority"));
		methods.add(new Method("Show the tasks for a given week (of seven days), given" + "\n"
				+ "the starting(first) date of that week", "show week <exactstartingdate>"));

		return methods;
	}
}
```
###### src\TestEventDoneInput.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest2.java tests that valid USUAL (EVENT) Task "lines" are true, using valid Task "lines", to test the logic of checkTask()
// format of an event task:

// input
// add <taskname>; <start>-<end> on <date>; <priority>

// output
// <taskname>, <start>-<end> on <date>, <priority>

// done
// <taskname>, <start>-<end> on <date>, <priority> [done]

public class TestEventDoneInput {

	@Test
	public void testOutput() throws IOException {

		// done event task input (user input and/or file storage form)
		assertTrue(Checker.isDoneEventTaskInput("task; 0000-0001 on 22/10/1110; priority [done]"));

		assertTrue(!Checker.isDoneEventTaskInput("task; 0002-0001 on 22/10/1110; priority [done]"));

		assertTrue(!Checker.isDoneEventTaskInput("task; 0000-0001 on 22/10/1110; priority[done]"));

		assertTrue(!Checker.isDoneEventTaskInput("task; 0000-0001 on 22/10/1110; priority [done"));

		assertTrue(!Checker.isDoneEventTaskInput("task; 0000-0001 on 22/10/1110; priority done]"));

		assertTrue(!Checker.isDoneEventTaskInput("task; 0000-0001 on 22/10/1110; priority [done]a"));

		assertTrue(!Checker.isDoneEventTaskInput("t, 0000-0001 1/1/1; priority"));

	}
}
```
###### src\TestEventDoneOutput.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest2.java tests that valid USUAL (EVENT) Task "lines" are true, using valid Task "lines", to test the logic of checkTask()
// format of an event task:

// input
// add <taskname>; <start>-<end> on <date>; <priority>

// output
// <taskname>, <start>-<end> on <date>, <priority>

// done
// <taskname>, <start>-<end> on <date>, <priority> [done]

public class TestEventDoneOutput {

	@Test
	public void testOutput() throws IOException {

		// done event task output(GUI display)
		assertTrue(Checker.isDoneEventTaskOutput("task, 0000-0001 on 22/10/1110, priority [done]"));

		assertTrue(!Checker.isDoneEventTaskOutput("task, 0002-0001 on 22/10/1110, priority [done]"));

		assertTrue(!Checker.isDoneEventTaskOutput("task, 0000-0001 on 22/10/1110, priority[done]"));

		assertTrue(!Checker.isDoneEventTaskOutput("task, 0000-0001 on 22/10/1110, priority [done"));

		assertTrue(!Checker.isDoneEventTaskOutput("task, 0000-0001 on 22/10/1110, priority done]"));

		assertTrue(!Checker.isDoneEventTaskOutput("task, 0000-0001 on 22/10/1110, priority [done]b"));

		assertTrue(!Checker.isDoneEventTaskOutput("t, 0000-0001 1/1/1, priority"));
		
	}
}
```
###### src\TestEventInput.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest2.java tests that valid USUAL (EVENT) Task "lines" are true, using valid Task "lines", to test the logic of checkTask()
// format of an event task:

// input
// add <taskname>; <start>-<end> on <date>; <priority>

public class TestEventInput {

	@Test
	public void testOutput() throws IOException {

		// event task input
		assertTrue(Checker.isEventTaskInput("task; 0000-0001 on 1/1/1; priority"));

		assertTrue(Checker.isEventTaskInput("task; 1201-1301 on 2/12/2015; priority"));
		
		assertTrue(Checker.isEventTaskInput("task; 1201-1301 on 3/12/2015; priority"));
		
		assertTrue(!Checker.isEventTaskInput("task; 0002-0001 on 1/1/1; priority"));

		assertTrue(!Checker.isEventTaskInput("task; 0000-0001 on 22/11/1111; priority [done]"));

		assertTrue(!Checker.isEventTaskInput("task; 0000-2400 on 22/11/1111; priority"));

		assertTrue(!Checker.isEventTaskInput("task; 0000-2400 on 22/11/1111; priority [done"));

		assertTrue(!Checker.isEventTaskInput("task; 0000-2400 on 22/11/1111; priority done]"));

	
	}
}
```
###### src\TestEventOutput.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest2.java tests that valid USUAL (EVENT) Task "lines" are true, using valid Task "lines", to test the logic of checkTask()
// format of an event task:

// output
// <taskname>, <start>-<end> on <date>, <priority>

public class TestEventOutput {

	@Test
	public void testOutput() throws IOException {

		// event task output
		assertTrue(Checker.isEventTaskOutput("task is about, 0000-0001 on 1/1/1, priority prior"));

		assertTrue(!Checker.isEventTaskOutput("task is about, 0002-0001 on 1/1/1, priority prior"));

		assertTrue(!Checker.isEventTaskOutput("task is about, 0000-0001 on 1/1/1, priority prior [done]"));

		assertTrue(!Checker.isEventTaskOutput("task is about, 0000-0001 on 1/1/1, priority prior [done"));

		assertTrue(!Checker.isEventTaskOutput("task is about, 0000-0001 on 1/1/1, priority prior done]"));

		// this is a case of invalid partition for the output (GUI Display)
		// String of an event task
		assertTrue(!Checker.isEventTaskOutput("task is about, 0000 0001 on 0/1/1, priority prior"));

	}
}
```
###### src\TestValidDate.java
``` java

import static org.junit.Assert.*;
import java.io.IOException;
import org.junit.Test;

// FlexTest3.java tests that the correct, valid date can be generated from a valid date

// Do take note that showWeek() uses generateNextDate(), and showWeek() has already called 
// checkDate() to verify the validity of the starting date of a week
// Therefore, only valid dates are used as for generateNextDate() 

public class TestValidDate {

	// number of days in each month for non-leap years
	private static final int JANUARY_DAYS = 31;
	private static final int FEBRUARY_DAYS = 28;
	private static final int MARCH_DAYS = 31;
	private static final int APRIL_DAYS = 30;
	private static final int MAY_DAYS = 31;
	private static final int JUNE_DAYS = 30;
	private static final int JULY_DAYS = 31;
	private static final int AUGUST_DAYS = 31;
	private static final int SEPTEMBER_DAYS = 30;
	private static final int OCTOBER_DAYS = 31;
	private static final int NOVEMBER_DAYS = 30;
	private static final int DECEMBER_DAYS = 31;

	@Test
	public void testOutput() throws IOException {
		// all these cases are in the valid date partition
		// they are not the boundary case of 1/1/1
		// however, if sub-boundaries exists, most of them are sub-boundary
		// cases of at the start or end of months
		// for different years
		assertEquals("generating the next date from 27/1/2014", "28/1/2014", ShowDays.generateNextDate("27/1/2014"));

		assertEquals("generating the next date from " + JANUARY_DAYS + " /1/2014", "1/2/2014",
				ShowDays.generateNextDate("31/1/2014"));

		// leap year case
		assertEquals("generating the next date from " + (FEBRUARY_DAYS + 1) + "29/2/2012", "1/3/2012",
				ShowDays.generateNextDate("29/2/2012"));

		// leap year case
		assertEquals("generating the next date from " + FEBRUARY_DAYS + " /2/2012", "29/2/2012",
				ShowDays.generateNextDate("28/2/2012"));

		assertEquals("generating the next date from " + JANUARY_DAYS + " /1/2013", "1/2/2013",
				ShowDays.generateNextDate("31/1/2013"));

		assertEquals("generating the next date from " + FEBRUARY_DAYS + " /2/2013", "1/3/2013",
				ShowDays.generateNextDate("28/2/2013"));

		assertEquals("generating the next date from " + MARCH_DAYS + " /3/2013", "1/4/2013",
				ShowDays.generateNextDate("31/3/2013"));

		assertEquals("generating the next date from " + APRIL_DAYS + " /4/2013", "1/5/2013",
				ShowDays.generateNextDate("30/4/2013"));

		assertEquals("generating the next date from " + MAY_DAYS + " /5/2013", "1/6/2013",
				ShowDays.generateNextDate("31/5/2013"));

		assertEquals("generating the next date from " + JUNE_DAYS + " /6/2013", "1/7/2013",
				ShowDays.generateNextDate("30/6/2013"));

		assertEquals("generating the next date from " + JULY_DAYS + " /7/2013", "1/8/2013",
				ShowDays.generateNextDate("31/7/2013"));

		assertEquals("generating the next date from " + AUGUST_DAYS + " /8/2013", "1/9/2013",
				ShowDays.generateNextDate("31/8/2013"));

		assertEquals("generating the next date from " + SEPTEMBER_DAYS + " /9/2013", "1/10/2013",
				ShowDays.generateNextDate("30/9/2013"));

		assertEquals("generating the next date from " + OCTOBER_DAYS + " /10/2013", "1/11/2013",
				ShowDays.generateNextDate("31/10/2013"));

		assertEquals("generating the next date from " + NOVEMBER_DAYS + " /11/2013", "1/12/2013",
				ShowDays.generateNextDate("30/11/2013"));

		assertEquals("generating the next date from " + DECEMBER_DAYS + " /12/2013", "1/1/2014",
				ShowDays.generateNextDate("31/12/2013"));
	}
}
```
