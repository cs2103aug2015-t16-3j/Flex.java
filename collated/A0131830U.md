# A0131830U
###### src\Command.java
``` java
public class Command {
     public enum Type{
    	 ADD,DELETE,CHANGE,UNDO,SHOW,MARK,SEARCH,CLEAR,EXIT,INVALID
     }
    
     private Type type;
     private String taskType;
     private String date;
     private String startTime;
     private String endTime;
     private String day;
     private String taskName;
     private String priority;
     private int number;
     private String keyWord;
     private String status;
     private String changedTaskName;
     private String changedDate;
     private String changedStartTime;
     private String changedEndTime;
     private String changedDay;
     private String changedPriority;
     private String showKeyword;
     private String searchType;
     
     public Command(Type type){
    	 this.type = type;
     }
     public Type getCommandType(){
    	 return type;
     }
     public String getTaskType(){
    	 return taskType;
     }
     public String getDate(){
    	 return date;
     }
     public String getstartTime(){
    	 return startTime;
     }
     public String getEndTime(){
    	 return endTime;
     }
     public String getDay(){
    	 return day;
     }
     public String getTaskName(){
    	 return taskName;
     }
     
     public String getPriority(){
    	 return priority;
     }
     
     public int getNumber(){
    	 return number;
     }
     public String getKeyWord(){
    	 return keyWord;
     }
     public String getStatus(){
    	 return status;
     }
     public String getChangedTaskName(){
    	 return changedTaskName;
     }
     public String getChangedDate(){
    	 return changedDate;
     }
     public String getChangedStartTime(){
    	 return changedStartTime;
     }
     public String getChangedEndTime(){
    	 return changedEndTime;
     }
     public String getChangedDay(){
    	 return changedDay;
     }
     public String getChangedPriority(){
    	 return changedPriority;
     }
     public String getShowKeyword(){
    	 return showKeyword;
     }
     public String getSearchType(){
    	 return searchType;
     }
     
  //----------------------------------------------------------------------------------------   
     public void setTaskType(String taskType){
    	 this.taskType = taskType;
     }
     public void setDate(String date){
    	 this.date = date;
     }
     public void setStartTime(String startTime){
    	 this.startTime = startTime;
     }
     public void setEndTime(String endTime){
    	 this.endTime = endTime;
     }
     public void setDay(String day){
    	 this.day = day;
     }
     
     public void setTaskName(String taskName){
    	 this.taskName = taskName;
     }
    
     public void setPriority(String priority){
    	 this.priority = priority;
     }
     public void setNumber(int number){
    	 this.number = number;
     }
     public void setKeyWord(String keyWord){
    	 this.keyWord = keyWord;
     }
     public void setStatus(String status){
    	 this.status = status;
     }
     public void setChangedTaskName(String changedTaskName){
    	 this.changedTaskName = changedTaskName;
     }
     public void setChangedDate(String changedDate){
    	 this.changedDate = changedDate;
     }
     public void setChangedStartTime(String changedStartTime){
    	 this.changedStartTime = changedStartTime;
     }
     public void setChangedEndTime(String changedEndTime){
    	 this.changedEndTime = changedEndTime;
     }
     public void setChangedDay(String changedDay){
    	 this.changedDay = changedDay;
     }
     public void setChangedPriority(String changedPriority){
    	 this.changedPriority = changedPriority;
     }
     public void setShowKeyword(String showKeyword){
    	 this.showKeyword = showKeyword;
     }
     public void setSearchType(String searchType){
    	 this.searchType = searchType;
     }
}
```
###### src\Flex.java
``` java
	
	static void readAndExecuteCommand(String filename, LastAction lastAction) throws IOException {
		FlexWindow.getTextArea().setText("");

		System.out.println();

		command.trim();
		
		System.out.println();

		int whitespaceIndex = 0;
		whitespaceIndex = command.indexOf(" ");
        
		Command commandInput = ParserSplit.parse(command);
        
	        // Note: clear the output display area after the user input command line
		// has been entered
		FlexWindow.getTextArea().setText("");
		switch(commandInput.getCommandType()){
		// Case 1: adding a task
		case ADD:      String remainingCommandString = command.substring(whitespaceIndex + 1).trim();
			           remainingCommandString.trim();

			           if (remainingCommandString.length() == 0) {
				       // INVALID if the remaining command string is empty
				       FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
				       FlexWindow.getFeedback().appendText("\n");

				       logger.finest(INVALID_INPUT_MESSAGE);
				       System.out.println(INVALID_INPUT_MESSAGE);
				       System.out.println();
			           } else {
                               
			        	   boolean isAddedTaskValid = (Checker.isFloatingTaskInput(remainingCommandString)
									|| Checker.isDoneFloatingTaskInput(remainingCommandString)
									|| Checker.isDeadlineTaskInput(remainingCommandString)
									|| Checker.isDoneDeadlineTaskInput(remainingCommandString)
									|| Checker.isEventTaskInput(remainingCommandString)
									|| Checker.isDoneEventTaskInput(remainingCommandString)
									|| Checker.isRecurringTaskInput(remainingCommandString));
				       
                      
				       // Only if the task is a floating task, a deadline task, or
				       // a
				       // normal task, then it will be attempted to be added to the
				       // .txt schedule file (i.e. tasks which are not done) yet
				      
			        	   if (isAddedTaskValid) {
								CRUD.addTask(filename, remainingCommandString,lastAction);
							} else {
								FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
								FlexWindow.getFeedback().appendText("\n");

								logger.finest(INVALID_INPUT_MESSAGE);
								System.out.println(INVALID_INPUT_MESSAGE);
								System.out.println();
							}
				       
			           }

			           SortAndShow.readAndDisplayAll(filename);
			           break;
	        // Case 2: adding a task
		case CHANGE:   String remainingCommandStringChange = command.substring(whitespaceIndex + 1).trim();
		               remainingCommandStringChange.trim();

					   if (remainingCommandStringChange.length() == 0) {
						   // INVALID if the remaining command string is empty
						   FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
						   FlexWindow.getFeedback().appendText("\n");

						   logger.finest(INVALID_INPUT_MESSAGE);
						   System.out.println(INVALID_INPUT_MESSAGE);
						   System.out.println();
					   } else {

						   // only if input is valid
						   // Note: This method will call readAndExecuteCommand again
						   CRUD.changeTaskVariable(filename, remainingCommandStringChange, lastAction);
					   }

					   SortAndShow.readAndDisplayAll(filename);
			           break;
		
	        // Case 3: Clear the entire .txt file
		case CLEAR:    CRUD.clear(filename, lastAction);
			           break;
		
                // Case 4: Deleting a task
		case DELETE:   String remainingCommandStringDelete = command.substring(whitespaceIndex + 1);
					   remainingCommandStringDelete = remainingCommandStringDelete.trim();

			           if (remainingCommandStringDelete.length() == 0) {
			        	   // INVALID if the remaining command string is empty
			        	   FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			        	   FlexWindow.getFeedback().appendText("\n");

			        	   logger.finest(INVALID_INPUT_MESSAGE);
			        	   System.out.println(INVALID_INPUT_MESSAGE);
			        	   System.out.println();
			           } else {

			        	   // only if input is valid
			        	   CRUD.deleteTask(filename, remainingCommandStringDelete, lastAction);
			           }

			           SortAndShow.readAndDisplayAll(filename);
			           break;
		
	        // Case 5:
		// Mark deadline, event or floating tasks as done or not done
                case MARK:     String remainingCommandStringMark = command.substring(whitespaceIndex + 1).trim();
                               remainingCommandStringMark.trim();

		               if (remainingCommandStringMark.length() == 0) {
		            	   // INVALID if the remaining command string is empty
		            	   FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
		            	   FlexWindow.getFeedback().appendText("\n");

		            	   logger.finest(INVALID_INPUT_MESSAGE);
		            	   System.out.println(INVALID_INPUT_MESSAGE);
		            	   System.out.println();
		               } else {

		            	   CRUD.markAsDone(filename, remainingCommandStringMark, lastAction);
		               }

		               SortAndShow.readAndDisplayAll(filename);
			           break;
		
	        // Case 6: Search for tasks
	        // (ignoring upper and lower cases),
	   	// and displaying the search results
		case SEARCH:   String remainingCommandStringSearch = command.substring(whitespaceIndex + 1).trim();
		               remainingCommandStringSearch.trim();

		               if (remainingCommandStringSearch.length() == 0) {
		            	   // INVALID if the remaining command string is empty
		            	   FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
		            	   FlexWindow.getFeedback().appendText("\n");

		            	   logger.finest(INVALID_INPUT_MESSAGE);
		            	   System.out.println(INVALID_INPUT_MESSAGE);
		            	   System.out.println();
		               }

		               // only if the input is valid
		               // Note: This method will call readAndExecuteCommand again
		               SortAndShow.searchAndShowTask(filename, remainingCommandStringSearch);

			           break;
		
	    	// Case 7:
	    	// Show tasks organized in groups
		// or show all tasks
		// in the schedule file
		// without altering/editing/overwriting the schedule file
		case SHOW:     String remainingStringShow = command.substring(whitespaceIndex + 1).trim();
		               remainingStringShow.trim();

			           // Note: The schedule file is already sorted by date and
			           // starting time

			           if ((remainingStringShow.equalsIgnoreCase("by date")) || (remainingStringShow.equalsIgnoreCase("all"))) {

			        	   SortAndShow.readAndDisplayAll(filename);

			           } else if (remainingStringShow.equalsIgnoreCase("by day")) {
			        	   logger.finest(RECURRING_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println(RECURRING_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println();

			        	   SortAndShow.showRecurringTasks(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("by taskname")
			        		   || remainingStringShow.equalsIgnoreCase("by task")) {
			        	   SortAndShow.showByTaskName(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("by start")) {
			        	   SortAndShow.showByTaskStartingTime(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("by end")) {
			        	   SortAndShow.showByTaskEndingTime(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("by priority")) {
			        	   SortAndShow.showByTaskPriority(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("done")) {

			        	   logger.finest(DONE_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println(DONE_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println();

			        	   SortAndShow.showDoneTasks(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("not done")) {

			        	   logger.finest(NOT_DONE_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println(NOT_DONE_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println();

			        	   SortAndShow.showNotDoneTasks(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("deadline")) {
			        	   logger.finest(DEADLINE_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println(DEADLINE_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println();

			        	   SortAndShow.showDeadlineTasks(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("floating") ||remainingStringShow.equalsIgnoreCase("by day")) {
			        	   logger.finest(FLOATING_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println(FLOATING_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println();

			        	   SortAndShow.showFloatingTasks(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("event") || remainingStringShow.equalsIgnoreCase("events")) {
			        	   logger.finest(EVENT_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println(EVENT_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println();

			        	   SortAndShow.showEventTasks(filename);
			           } else if (remainingStringShow.equalsIgnoreCase("recurring")) {
			        	   logger.finest(RECURRING_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println(RECURRING_TASKS_DISPLAYED_MESSAGE);
			        	   System.out.println();

			        	   SortAndShow.showRecurringTasks(filename);
			           } else if (remainingStringShow.indexOf("week ") == 0) {
			        	   String date = remainingStringShow.substring(5);
			        	   if (date.length() == 0) {
			        		   FlexWindow.getTextArea().appendText(INVALID_INPUT_MESSAGE + "\n");
			        		   FlexWindow.getTextArea().appendText("\n");

			        		   logger.finest(INVALID_INPUT_MESSAGE);
			        		   System.out.println(INVALID_INPUT_MESSAGE);
			        		   System.out.println();
			        	   } else {
			        		   ShowDays.showWeek(filename, date);
			        		   SortAndShow.showRecurringTasks(filename);
			        	   }
			           } else {
			        	   FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
			        	   FlexWindow.getFeedback().appendText("\n");

			        	   logger.finest(INVALID_INPUT_MESSAGE);
			        	   System.out.println(INVALID_INPUT_MESSAGE);
			        	   System.out.println();

			           }
			           break;
		
	    	// Case 8: undo the last action
	    	// Note: This method will call readAndExecuteCommand again
	  	case UNDO:     CRUD.undo(filename, lastAction);

		               SortAndShow.readAndDisplayAll(filename);
			           break;
	    
	    	// Case 9: The program Flex.java will exit itself in Command Line
		// Prompt (cmd).
		case EXIT:     FlexWindow.getFeedback().appendText(EXIT_MESSAGE + "\n");
		               FlexWindow.getFeedback().appendText("\n");

		               logger.finest(EXIT_MESSAGE);
		               System.out.println(EXIT_MESSAGE);
		               System.out.println();

		               System.exit(1);
	                   break;
	    	// Case 10: invalid input
		default:       FlexWindow.getFeedback().appendText(INVALID_INPUT_MESSAGE + "\n");
		               FlexWindow.getFeedback().appendText("\n");

		               logger.finest(INVALID_INPUT_MESSAGE);
		               System.out.println(INVALID_INPUT_MESSAGE);
		               System.out.println();
                       break;
           
		}
	}	
}
```
###### src\ParserSplit.java
``` java
//ParserSplit is to parser the input command, find the command type and the arguments.
import java.util.*;
public class ParserSplit {
    private static final String COMMAND_ADD = "add";
    private static final String COMMAND_DELETE = "delete";
    private static final String COMMAND_CHANGE = "change";
    private static final String COMMAND_MARK = "mark";
    private static final String COMMAND_UNDO = "undo";
    private static final String COMMAND_SHOW = "show";
    private static final String COMMAND_SEARCH = "search";
    private static final String COMMAND_EXIT = "exit";
    private static final String COMMAND_CLEAR = "clear";
    
    
    
    
    public static Command parse(String userInput){
    	Command command;
    	ArrayList<String> parameters = splitString(userInput);
    	String commandType = getCommandType(parameters);
    	String arguments = getArguments(parameters);
    	switch(commandType.toLowerCase()){
	      case COMMAND_ADD : command = addCommand(arguments);
	                         break;
	      case COMMAND_DELETE: command = deleteCommand(arguments);
	                           break;
	      case COMMAND_CHANGE: command = changeCommand(arguments);
    	                       break;
	      case COMMAND_UNDO: command = undoCommand();
	                         break;
	      case COMMAND_SHOW: command = showCommand(arguments);
	                         break;
	      case COMMAND_MARK: command = markCommand(arguments);
	                         break;
	      case COMMAND_SEARCH: command = searchCommand(arguments);
	                         break;
	      case COMMAND_CLEAR: command = clearCommand();
	                         break;
	      case COMMAND_EXIT: command = exitCommand();
	                         break;
	      default: command = invalidCommand();
    	}
    	return command;
    	} 
    //split the input command into two parts
    private static ArrayList<String> splitString(String userInput){
    	String[] temp = userInput.trim().split(" ", 2);
    	return new ArrayList<String>(Arrays.asList(temp));
    }
    // return the command type
    private static String getCommandType(ArrayList<String> parameters){
    	return parameters.get(0);
    }
    //return the arguments
    private static String getArguments(ArrayList<String> parameters){
    	String nulltemp = "";
    	if(parameters.size()<2){
    		return nulltemp;
    	}
    	String temp = parameters.get(1);
    	return temp;
        }
    
    // add command type
    private static Command addCommand(String arguments) {
    	if(arguments.trim().length()==0){
    		Command command = new Command(Command.Type.INVALID);
    		return command;
    	}
       	Command command = new Command(Command.Type.ADD);
    	if(arguments.contains("by")&&arguments.contains("on")){
    		command.setTaskType("Deadline");
    		String[] splitFirst = arguments.trim().split("; ");
    		String taskName = splitFirst[0];
    		String[] splitSec = splitFirst[1].trim().split(" ");
    		String endTime = splitSec[1];
    		String date = splitSec[3];
    		if(arguments.contains("[done]")){
    			String statusD = "done";
    			command.setStatus(statusD);
    		}
    		command.setTaskName(taskName);
    		command.setEndTime(endTime);
    		command.setDate(date);
    		return command;
    	}
    	else if(arguments.contains("on")){
    		command.setTaskType("Event");
    		String[] splitFirst = arguments.trim().split("; ");
    		String taskName = splitFirst[0];
    		if(splitFirst[2].contains("[done]")){
    			String[] splitFourth = splitFirst[2].trim().split(" ");
    			String priorityN = splitFourth[0];
    			String statusN = "done";
    			command.setPriority(priorityN);
    			command.setStatus(statusN);
    		}
    		else{
    		String priority = splitFirst[2];
    		command.setPriority(priority);
    		}
    		String[] splitSec = splitFirst[1].trim().split(" ");
    		String date = splitSec[2];
    		String[] splitThird = splitSec[0].trim().split("-");
    		String startTime = splitThird[0];
    		String endTime = splitThird[1];
    		
    		command.setTaskName(taskName);
    		command.setStartTime(startTime);
    		command.setEndTime(endTime);
    		command.setDate(date);
    		
    		return command;
    	}
    	else if(arguments.contains("every")){
    		command.setTaskType("Recurring");
    		String[] splitFirst = arguments.trim().split("; ");
    		String taskName = splitFirst[0];
    		String[] splitSec = splitFirst[1].trim().split(" ");
    		String day = splitSec[2];
    		String[] splitThird = splitSec[0].trim().split("-");
    		String startTime = splitThird[0];
    		String endTime = splitThird[1];
    		command.setTaskName(taskName);
    		command.setStartTime(startTime);
    		command.setEndTime(endTime);
    		command.setDay(day);
    		return command;
    	}
    	else{
    		command.setTaskType("Floating");
    		if(arguments.contains("[done]")){
    			String[] splitF = arguments.trim().split(" ");
    			String taskNameF = splitF[0];
    			String statusF = "done";
    			command.setTaskName(taskNameF);
    			command.setStatus(statusF);
    		}
    		else{
    		String taskName = arguments.trim();
    		command.setTaskName(taskName);
    		}
    		return command;
    	}
      
    }
    // delete command type
    private static Command deleteCommand(String arguments){
    	if(arguments.trim().length()==0){
    		Command command = new Command(Command.Type.INVALID);
    		return command;
    	}
    	Command command = new Command(Command.Type.DELETE);
    	if(arguments.contains("floating")){
    		command.setTaskType("Floating");
    		String[] splitFirst = arguments.split(" ");
    		int number = Integer.valueOf(splitFirst[1]);
    		command.setNumber(number);
    		return command;
    	}
    	else if(arguments.contains("rec")){
    		command.setTaskType("Recurring");
    		String[] splitFirst = arguments.split(" ");
    		int number = Integer.valueOf(splitFirst[1]);
    		command.setNumber(number);
    		return command;
    	}
    	else{
    		command.setTaskType("Event");
    		String[] splitFirst = arguments.split(" ");
    		String date = splitFirst[0];
    		int number = Integer.valueOf(splitFirst[1]);
    		command.setDate(date);
    		command.setNumber(number);
    		return command;
    	}
    	
    }
    // change command type
    private static Command changeCommand(String arguments) {
    	if(arguments.trim().length()==0){
    		Command command = new Command(Command.Type.INVALID);
    		return command;
    	}
    	Command command = new Command(Command.Type.CHANGE);
    	if(arguments.contains("rec")){
    		command.setTaskType("Recurring");
    		String[] splitRecFirst = arguments.trim().split(" ", 3);
    		int number = Integer.valueOf(splitRecFirst[1]);
    		command.setNumber(number);
    		if(splitRecFirst[2].contains("taskname")){
    			String[] splitRecSec = splitRecFirst[2].trim().split(" ");
    			String newRecTaskName = splitRecSec[2].trim();
    			command.setChangedTaskName(newRecTaskName);
    		}
    		else if(splitRecFirst[2].contains("every")){
    			String[] splitRecThird = splitRecFirst[2].trim().split(" ");
    			String newDay = splitRecThird[2].trim();
    			command.setChangedDay(newDay);
    		}
    		else if(splitRecFirst[2].contains("time")){
    			String[] splitRecFourth = splitRecFirst[2].trim().split(" ");
    			String startEndTime = splitRecFourth[2].trim();
    			String[] splitRecFifth = startEndTime.split("-");
    			String newStart = splitRecFifth[0].trim();
    			String newEnd = splitRecFifth[1].trim();
    			command.setChangedStartTime(newStart);
    			command.setChangedEndTime(newEnd);
    		}
        }
    	else if(arguments.contains("floating")){
      		 command.setTaskType("floating");
      		 String[] splitFloFirst = arguments.trim().split(" ",3);
      		 int FloNumber = Integer.valueOf(splitFloFirst[1]);
      		 command.setNumber(FloNumber);
      		 if(splitFloFirst[2].contains("taskname to")){
      			 String[] splitFloSec = splitFloFirst[2].trim().split(" ");
      			 String newFloTaskName = splitFloSec[2].trim();
      			 command.setChangedTaskName(newFloTaskName);
      		 }
      		 
      	}
    	else if(arguments.contains("by")){
       		command.setTaskType("Deadline");
       		String[] splitDeadFirst = arguments.trim().split(" ", 3);
       		String deadDate = splitDeadFirst[0].trim();
       		int deadNumber = Integer.valueOf(splitDeadFirst[1]);
       		command.setDate(deadDate);
       		command.setNumber(deadNumber);
       		if(splitDeadFirst[2].contains("end by")){
       			String[] splitDeadSec = splitDeadFirst[2].trim().split(" ");
       			String deadEnd = splitDeadSec[2].trim();
       			command.setChangedEndTime(deadEnd);
       		}
       		else if(splitDeadFirst[2].contains("by") && splitDeadFirst[2].contains("on")){
       			String[] splitDeadThird = splitDeadFirst[2].trim().split(" ");
       			String newdeadEnd = splitDeadThird[1].trim();
       			String newdeadDate = splitDeadThird[3].trim();
       			command.setChangedEndTime(newdeadEnd);
       			command.setChangedDate(newdeadDate);
       		}
       	}
    	else{
       		command.setTaskType("Event");
       		String[] splitFirst = arguments.trim().split(" ", 3);
       		String date = splitFirst[0];
       		int number = Integer.valueOf(splitFirst[1]);
       		command.setDate(date);
       		command.setNumber(number);
       		if(splitFirst[2].contains("taskname")){
       			String[] splitSec = splitFirst[2].trim().split(" ");
       			String newTaskName = splitSec[2].trim();
       			command.setChangedTaskName(newTaskName);
       		}
       		else if(splitFirst[2].contains("date")){
       			String[] splitThird = splitFirst[2].trim().split(" ");
       			String newDate = splitThird[2].trim();
       			command.setChangedDate(newDate);
       		}
       		else if(splitFirst[2].contains("priority")){
       			String[] splitFourth = splitFirst[2].trim().split(" ");
       			String newPriority = splitFourth[2].trim();
       			command.setChangedPriority(newPriority);
       		}
       		else if(splitFirst[2].contains("time")){
       			String[] splitFifth = splitFirst[2].trim().split(" ");
       			String newTime = splitFifth[2];
       			String[] newTimeSplit = newTime.trim().split("-");
       			String newStartTime = newTimeSplit[0];
       			String newEndTime = newTimeSplit[1];
       			command.setChangedStartTime(newStartTime);
       			command.setChangedEndTime(newEndTime);
       		}
       		
       	}
    	return command;
     
 }
    //mark task as done or not done
    private static Command markCommand(String arguments){
    	if(arguments.trim().length()==0){
    		Command command = new Command(Command.Type.INVALID);
    		return command;
    	}
    	Command command = new Command(Command.Type.MARK);
    	if(arguments.contains("not done")){
    		command.setStatus("not done");
    	}
    	else if(arguments.contains("done")){
    		command.setStatus("done");
    	}
    	return command;
    }
    // search command type
    private static Command searchCommand(String arguments){
    	if(arguments.trim().length()==0){
    		Command command = new Command(Command.Type.INVALID);
    		return command;
    	}
    	
    	String[] splitFir = arguments.split(" ");
    	Command command = new Command(Command.Type.SEARCH);
    	command.setKeyWord(splitFir[1].trim());
    	if(arguments.contains("date")){
    		command.setSearchType("date");
        }
    	if(arguments.contains("taskname")){
    		command.setSearchType("taskname");
    	}
    	if(arguments.contains("day")){
    		command.setSearchType("day");
    	}
    	if(arguments.contains("start")){
    		command.setSearchType("startTime");
    	}
    	if(arguments.contains("end")){
    		command.setSearchType("endTime");
    	}
    	if(arguments.contains("priority")){
    		command.setSearchType("priority");
    	}
    	return command;
    }
   
    // show command type
    private static Command showCommand(String arguments){
    	if(arguments.trim().length()==0){
    		Command command = new Command(Command.Type.INVALID);
    		return command;
    	}
    	Command command = new Command(Command.Type.SHOW);
    	if(arguments.contains("by")){
    		String[] splitString = arguments.split(" ");
    		String splitKeyword = splitString[1].trim();
    		command.setShowKeyword(splitKeyword);
    	}
    	
    	else if(arguments.contains("week")){
    		String[] splitStringSec = arguments.split(" ");
    		String splitKeyWordWeek = splitStringSec[1].trim();
    		command.setShowKeyword(splitKeyWordWeek);
    	}
    	else if(!arguments.trim().equals("")){
    		String showKeyword = arguments.trim();
    		command.setShowKeyword(showKeyword);
    	}
    	return command;
    }
    
    // undo command type
    private static Command undoCommand(){
    	Command command = new Command(Command.Type.UNDO);
    	return command;
    }
    private static Command clearCommand(){
    	Command command = new Command(Command.Type.CLEAR);
    	return command;
    }
    // exit command type
    private static Command  exitCommand(){
    	Command command = new Command(Command.Type.EXIT);
    	return command;
    }
    
    //invalid command type
    private static Command invalidCommand(){
    	Command command = new Command(Command.Type.INVALID);
    	return command;
    }
}
```
###### src\ParserSplitChangeUnitTest.java
``` java
import static org.junit.Assert.*;

import org.junit.Test;

public class ParserSplitChangeUnitTest {
    Command changeNormaltasknameCommand = ParserSplit.parse("change 01/01/2015 1 taskname to ttt");
    Command changeNormalDateCommand = ParserSplit.parse("change 01/01/2015 1 date to 02/01/2015");
    Command changeNormalPriorityCommand = ParserSplit.parse("change 01/01/2015 1 priority to 1");
    Command changeNormalTimeCommand = ParserSplit.parse("change 01/01/2015 1 time to 1000-1100");
    Command changeDeadlineEndtimeCommand = ParserSplit.parse("change 01/01/2015 1 end by 1200");
    Command changeFloatingTasknameCommand = ParserSplit.parse("change floating 1 taskname to ttt");
    Command changeRecurringTasknameCommand = ParserSplit.parse("change rec 1 taskname to ttt");
    Command changeRecurringDayCommand = ParserSplit.parse("change rec 1 to every tuesday");
    Command changeRecurringTime = ParserSplit.parse("change rec 1 time to 1000-1100");
    Command markNormaltaskDone = ParserSplit.parse("mark 01/01/2015 1 done");
    Command markNormalTaskNotDone = ParserSplit.parse("mark 01/01/2015 1 not done");
    Command markFloatingTaskDone = ParserSplit.parse("mark floating 1 done");
    Command markFloatingTaskNotDone = ParserSplit.parse("mark floating 1 not done");
    
    //check for change of the normal task taskname
	@Test
	public void changeNormalTasknameCommand() {
		assertEquals("01/01/2015", changeNormaltasknameCommand.getDate());
		assertEquals(1, changeNormaltasknameCommand.getNumber());
		assertEquals("ttt", changeNormaltasknameCommand.getChangedTaskName());
	}
	
	//check for change of the normal task date
    public void changeNormalDateCommand(){
		assertEquals("01/01/2015", changeNormaltasknameCommand.getDate());
		assertEquals(1, changeNormaltasknameCommand.getNumber());
		assertEquals("02/01/2015", changeNormaltasknameCommand.getChangedDate());
	}
	
    //check for change of the normal task priority
	public void changeNormalPriorityCommand(){
		assertEquals("01/01/2015", changeNormalPriorityCommand.getDate());
		assertEquals(1, changeNormalPriorityCommand.getNumber());
		assertEquals("2",changeNormalPriorityCommand.getChangedPriority());
		
	}
	
	//check for change of the normal task time
	public void changeNormalTimeCommand(){
		assertEquals("01/01/2015", changeNormalTimeCommand.getDate());
		assertEquals(1, changeNormalTimeCommand.getNumber());
		assertEquals("1000", changeNormalTimeCommand.getChangedStartTime());
		assertEquals("1100", changeNormalTimeCommand.getChangedEndTime());
	}
    
	//check for change of the deadline endtime
	public void changeDeadLineEndTimeCommand(){
		assertEquals("01/01/2015", changeDeadlineEndtimeCommand.getDate());
		assertEquals(1, changeDeadlineEndtimeCommand.getNumber());
		assertEquals("1200", changeDeadlineEndtimeCommand.getEndTime());
	}
	
	//check for change of the floating taskname
	public void changeFloatingTasknameCommand(){
		assertEquals(1, changeFloatingTasknameCommand.getNumber());
		assertEquals("ttt", changeFloatingTasknameCommand.getChangedTaskName());
	}
	
	//check for change of the recurring taskname
	public void changeRecurringTasknameCommand(){
		assertEquals(1, changeRecurringTasknameCommand.getNumber());
		assertEquals("ttt", changeRecurringTasknameCommand.getChangedTaskName());
	}
	
	//check for change of the recurring day
	public void changeRecurringDayCommand(){
		assertEquals(1, changeRecurringDayCommand.getNumber());
		assertEquals("tuesday", changeRecurringDayCommand.getChangedDay());
	}
	
	//check for change of the recurring time
	public void changeRecurringTimeCommand(){
		assertEquals(1, changeRecurringTime.getNumber());
		assertEquals("1000", changeRecurringTime.getChangedStartTime());
		assertEquals("1100", changeRecurringTime.getChangedEndTime());
	}
	
	//check for mark normal task as done
	public void markNormalTaskDone(){
		assertEquals("01/01/2015", markNormaltaskDone.getDate());
		assertEquals(1, markNormaltaskDone.getNumber());
		assertEquals("done", markNormaltaskDone.getStatus());
	}
	
	//check for mark normal task as not done
	public void markNormalTaskNotDone(){
		assertEquals("01/01/2015", markNormalTaskNotDone.getDate());
		assertEquals(1, markNormalTaskNotDone.getNumber());
		assertEquals("not done", markNormalTaskNotDone.getStatus());
	}
	
	//check for mark floating task as done
    public void markFloatingTaskDone(){
    	assertEquals(1, markFloatingTaskDone.getNumber());
    	assertEquals("done", markFloatingTaskDone.getStatus());
    }
    
    //check for mark floating task as not done
    public void markFloatingTaskNotDone(){
    	assertEquals(1,markFloatingTaskNotDone.getNumber());
    	assertEquals("not done", markFloatingTaskNotDone.getStatus());
    }
	
}
```
###### src\ParserSplitDeleteUnitTest.java
``` java
import static org.junit.Assert.assertEquals;

import org.junit.Test;

public class ParserSplitDeleteUnitTest {
	Command deleteNormalEvent = ParserSplit.parse("delete 01/01/2015 3");
    Command deleteCommandFloating = ParserSplit.parse("delete floating 1");
    Command deleteCommandRecurring = ParserSplit.parse("delete rec 1");
	
	
	@Test
	//check for the delete normal event and deadline task
	public void testDeleteCommandEvent(){
		assertEquals("01/01/2015", deleteNormalEvent.getDate());
		assertEquals(3, deleteNormalEvent.getNumber());
	}
	
	//check for the delete floating task
	public void testDeleteCommandFloating(){
		assertEquals("floating", deleteCommandFloating.getTaskType());
		assertEquals(1, deleteCommandFloating.getNumber());
	}
	//check for the delete recurring task
	public void testDeleteCommandRecurring(){
		assertEquals("recurring", deleteCommandRecurring.getTaskType());
		assertEquals(1, deleteCommandRecurring.getNumber());
	}
}
```
###### src\ParserSplitSearchUnitTest.java
``` java
import static org.junit.Assert.*;

import org.junit.Test;

public class ParserSplitSearchUnitTest {
    Command searchTasknameCommand = ParserSplit.parse("search taskname ttt");
    Command searchDateCommand = ParserSplit.parse("search date 01/01/2015");
    Command searchDayCommand = ParserSplit.parse("search day Tuesday");
    Command searchStartCommand = ParserSplit.parse("search start 1000");
    Command searchEndCommand = ParserSplit.parse("search end 1100");
    Command searchPriority = ParserSplit.parse("search priority 1");
	@Test
	public void searchTaskname() {
	     assertEquals("taskname", searchTasknameCommand.getSearchType());
	     assertEquals("ttt", searchTasknameCommand.getKeyWord());
	}
	public void searchDate(){
		assertEquals("date", searchDateCommand.getSearchType());
		assertEquals("01/01/2015", searchDateCommand.getKeyWord());
	}
	public void searchDay(){
		assertEquals("day", searchDayCommand.getSearchType());
		assertEquals("Tuesday", searchDayCommand.getKeyWord());
	}
	
	public void searchStart(){
		assertEquals("start", searchStartCommand.getSearchType());
		assertEquals("1000",searchStartCommand.getKeyWord());
	}
    public void searchEnd(){
    	assertEquals("end", searchEndCommand.getSearchType());
    	assertEquals("1100", searchEndCommand.getKeyWord());
    }
    public void searchPriority(){
    	assertEquals("priority", searchPriority.getSearchType());
    	assertEquals("1",searchPriority.getKeyWord());
    }
}
```
###### src\ParserSplitShowUnitTest.java
``` java
import static org.junit.Assert.*;

import org.junit.Test;

public class ParserSplitShowUnitTest {
    Command showallTask = ParserSplit.parse("show all");
    Command showdoneTask = ParserSplit.parse("show done");
    Command shownotdoneTask = ParserSplit.parse("show not done");
    Command showdeadlineTask = ParserSplit.parse("show deadline");
    Command showeventTask = ParserSplit.parse("show event");
    Command showrecurringTask = ParserSplit.parse("show recurring");
    Command showfloatingTask = ParserSplit.parse("show floating");
    Command showtaskname = ParserSplit.parse("show by taskname");
    Command showdate = ParserSplit.parse("show by date");
    Command showday = ParserSplit.parse("show by day");
    Command showstart = ParserSplit.parse("show by start");
    Command showEnd = ParserSplit.parse("show by end");
    Command showpriority = ParserSplit.parse("show by priority");
	@Test
	public void showAllTask() {
		assertEquals("all", showallTask.getShowKeyword());
		
	}
	public void showDoneTask(){
		assertEquals("done", showdoneTask.getShowKeyword());
	}
    
	public void showNotDoneTask(){
		assertEquals("not done", shownotdoneTask.getShowKeyword());
	}
	
	public void showDeadlineTask(){
		assertEquals("deadline", showdeadlineTask.getShowKeyword());
	}
	public void showEventTask(){
		assertEquals("event", showeventTask.getShowKeyword());
	}
	
	public void showRecurringTask(){
		assertEquals("recurring", showrecurringTask.getShowKeyword());
	}
	
	public void showFloatingTask(){
		assertEquals("floating", showfloatingTask.getShowKeyword());
	}
	
	public void showTaskName(){
		assertEquals("taskname", showtaskname.getShowKeyword());
	}
	
	public void showDate(){
		assertEquals("date", showdate.getShowKeyword());
	}
	
	public void showDay(){
		assertEquals("day", showday.getShowKeyword());
	}
	
	public void showStart(){
		assertEquals("start", showstart.getShowKeyword());
	}
	
	public void showEnd(){
		assertEquals("end", showEnd.getShowKeyword());
	}
	
	public void showPriority(){
		assertEquals("priority", showpriority.getShowKeyword());
	}
}
```
###### src\ParserSplitTest.java
``` java
public class ParserSplitTest {
	public static void main(String[] args){
		//add normal task
		Command add = ParserSplit.parse("add taskname; 1000-1100 on 01/01/2015; 1");
		System.out.println(add.getCommandType()+ " "+add.getTaskType());
		System.out.println(add.getTaskName()+" " + add.getstartTime() +" " +add.getEndTime()+" "+add.getDate()+" "+add.getPriority());
		
		//add deadline
		Command addDead = ParserSplit.parse("add taskname; by 1000 on 01/01/2015");
		System.out.println(addDead.getCommandType()+ " "+addDead.getTaskType());
		System.out.println(addDead.getTaskName() +" "+ addDead.getEndTime()+" "+addDead.getDate());
		
		//add recurring task
		Command addRec = ParserSplit.parse("add taskname; 1000-1100 every Tuesday; 1");
		System.out.println(addRec.getCommandType() + " "+addRec.getTaskType());
		System.out.println(addRec.getTaskName()+" "+addRec.getstartTime()+ " "+addRec.getEndTime()+" "+addRec.getDay()+" "+addRec.getPriority());
		
		//add floating task
		Command addFlo = ParserSplit.parse("add taskname");
		System.out.println(addFlo.getCommandType()+ " "+addFlo.getTaskType());
		System.out.println(addFlo.getTaskName());
		
		
		//delete floating task
		Command deleteFlo = ParserSplit.parse("delete floating 3");
		System.out.println(deleteFlo.getCommandType()+ " "+deleteFlo.getTaskType());
		System.out.println(deleteFlo.getNumber());
		
		//delete normal task
		Command delete = ParserSplit.parse("delete 01/01/2015 3");
		System.out.println(delete.getCommandType()+ " "+delete.getTaskType());
		System.out.println(delete.getDate() +" "+delete.getNumber());
		
		//delete recurring task
		Command deleteRec = ParserSplit.parse("delete rec 4");
		System.out.println(deleteRec.getCommandType()+ " "+deleteRec.getTaskType());
		System.out.println(deleteRec.getNumber());
		
		//search keyword
		Command search = ParserSplit.parse("search apple");
		System.out.println(search.getCommandType());
		System.out.println(search.getKeyWord());
		
		//change normal task
		Command change = ParserSplit.parse("change 01/01/2015 1 taskName to TaskName");
		System.out.println(change.getCommandType() +" "+change.getTaskType());
		System.out.println(change.getDate() + " "+ change.getNumber()+" "+ change.getChangedTaskName());
		
		//show not done
		Command showNotDone = ParserSplit.parse("show not done");
		System.out.println(showNotDone.getCommandType());
		System.out.println(showNotDone.getShowKeyword());
		
	}
}
```
###### src\ParserSplitUnitTest.java
``` java
import static org.junit.Assert.*;

import org.junit.Test;

public class ParserSplitUnitTest {
	Command addNormalEvent = ParserSplit.parse("add taskname; 1000-1100 on 01/01/2015; 1");
    Command addCommandDeadline = ParserSplit.parse("add taskname; by 1200 on 01/01/2015");
    Command addCommandFloating = ParserSplit.parse("add taskname");
    Command addCommandRecurring = ParserSplit.parse("add taskname; 1000-1100 every tuesday");
	
	
	@Test
	//check for the add normal task
	public void testAddCommandEvent(){
		assertEquals("taskname", addNormalEvent .getTaskName());
		assertEquals("1000", addNormalEvent .getstartTime());
		assertEquals("1100", addNormalEvent .getEndTime());
		assertEquals("01/01/2015", addNormalEvent .getDate());
		assertEquals("1", addNormalEvent .getPriority());
	}
	
	//check for the add deadline task
	public void testAddDeadline(){
		assertEquals("taskname", addCommandDeadline.getTaskName());
		assertEquals("1200", addCommandDeadline.getEndTime());
		assertEquals("01/01/2015",addCommandDeadline.getDate());
	}
	
	//check for the add floating task
	public void testAddFloating(){
		assertEquals("taskname", addCommandFloating.getTaskName());
	}
	
	
	//check for the add recurring task
	public void testAddRecurring(){
		assertEquals("taskname", addCommandRecurring.getTaskName());
		assertEquals("1000", addCommandRecurring.getstartTime());
		assertEquals("1100", addCommandRecurring.getEndTime());
		assertEquals("tuesday", addCommandRecurring.getDay());
	}
 
}
```
